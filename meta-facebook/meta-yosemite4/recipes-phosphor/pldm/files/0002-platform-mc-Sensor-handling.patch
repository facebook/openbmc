From 5c69fa67b1beddb418e7e3fc20714d399716dcc6 Mon Sep 17 00:00:00 2001
From: Gilbert Chen <gilbert.chen@arm.com>
Date: Wed, 23 Feb 2022 20:56:19 +0000
Subject: [PATCH 2/8] platform-mc: Sensor handling

Added sensor_manager and numeric_sensor class. The sensor_manager
class manages the timing of sensor polling. The NumericSensor class
handles sensor status and exports its status to D-Bus interfaces.

tested: Verified on ast2600 EVB which is connected to a PLDM device
over I2C. bmcweb can display the state of numeric sensor.

Signed-off-by: Gilbert Chen <gilbert.chen@arm.com>
Signed-off-by: Thu Nguyen <thu@os.amperecomputing.com>
Change-Id: I4257f823ea26d7fdb322cc82d847e94db056258c
---
 meson.build                                |   6 +
 meson.options                              |  24 +
 platform-mc/examples/pldm_t2_config.json   |  12 +
 platform-mc/manager.hpp                    |  21 +-
 platform-mc/numeric_sensor.cpp             | 687 +++++++++++++++++++++
 platform-mc/numeric_sensor.hpp             | 219 +++++++
 platform-mc/sensor_manager.cpp             | 410 ++++++++++++
 platform-mc/sensor_manager.hpp             | 117 ++++
 platform-mc/terminus.cpp                   | 114 +++-
 platform-mc/terminus.hpp                   |  30 +
 platform-mc/terminus_manager.cpp           |  18 +
 platform-mc/test/meson.build               |   4 +
 platform-mc/test/mock_sensor_manager.hpp   |  24 +
 platform-mc/test/numeric_sensor_test.cpp   | 272 ++++++++
 platform-mc/test/platform_manager_test.cpp |   3 +
 platform-mc/test/sensor_manager_test.cpp   | 147 +++++
 pldmd/pldmd.cpp                            |   2 +-
 17 files changed, 2107 insertions(+), 3 deletions(-)
 create mode 100644 platform-mc/examples/pldm_t2_config.json
 create mode 100644 platform-mc/numeric_sensor.cpp
 create mode 100644 platform-mc/numeric_sensor.hpp
 create mode 100644 platform-mc/sensor_manager.cpp
 create mode 100644 platform-mc/sensor_manager.hpp
 create mode 100644 platform-mc/test/mock_sensor_manager.hpp
 create mode 100644 platform-mc/test/numeric_sensor_test.cpp
 create mode 100644 platform-mc/test/sensor_manager_test.cpp

diff --git a/meson.build b/meson.build
index 100c0f9..68b1cc4 100644
--- a/meson.build
+++ b/meson.build
@@ -72,6 +72,10 @@ if get_option('transport-implementation') == 'mctp-demux'
 elif get_option('transport-implementation') == 'af-mctp'
   conf_data.set('PLDM_TRANSPORT_WITH_AF_MCTP', 1)
 endif
+conf_data.set_quoted('STATIC_EID_TABLE_PATH', join_paths(package_datadir, 'static_eid_table.json'))
+conf_data.set('SENSOR_POLLING_TIME', get_option('sensor-polling-time'))
+conf_data.set('DEFAULT_SENSOR_UPDATER_INTERVAL', get_option('default-sensor-update-interval'))
+conf_data.set_quoted('PLDM_T2_CONFIG_JSON', join_paths(package_datadir, 'pldm_t2_config.json'))
 
 configure_file(output: 'config.h',
   configuration: conf_data
@@ -173,6 +177,8 @@ executable(
   'platform-mc/terminus.cpp',
   'platform-mc/platform_manager.cpp',
   'platform-mc/manager.cpp',
+  'platform-mc/sensor_manager.cpp',
+  'platform-mc/numeric_sensor.cpp',
   'requester/mctp_endpoint_discovery.cpp',
   implicit_include_directories: false,
   dependencies: deps,
diff --git a/meson.options b/meson.options
index d52506e..3e0aec8 100644
--- a/meson.options
+++ b/meson.options
@@ -174,3 +174,27 @@ option(
     value: 8384512,
     description: 'OEM-IBM: max DMA size'
 )
+
+# Platform-mc configuration parameters
+
+## Sensor Polling Options
+option(
+    'sensor-polling-time',
+    type: 'integer',
+    min: 1,
+    max: 4294967295,
+    description: 'The interval time of sensor polling in milliseconds',
+    value: 249
+)
+
+## Default Sensor Update Interval Options
+option(
+    'default-sensor-update-interval',
+    type: 'integer',
+    min: 1,
+    max: 4294967295,
+    description: '''The default interval time of sensor updating in
+                    milliseconds.''',
+
+    value: 999
+)
diff --git a/platform-mc/examples/pldm_t2_config.json b/platform-mc/examples/pldm_t2_config.json
new file mode 100644
index 0000000..4300fd3
--- /dev/null
+++ b/platform-mc/examples/pldm_t2_config.json
@@ -0,0 +1,12 @@
+{
+    "PrioritySensorNameSpaces": [
+        "/xyz/openbmc_project/sensors/temperature/",
+        "/xyz/openbmc_project/sensors/power/",
+        "/xyz/openbmc_project/sensors/energy/"
+    ],
+    "AggregationSensorNameSpaces": [
+        "/xyz/openbmc_project/sensors/temperature/",
+        "/xyz/openbmc_project/sensors/power/",
+        "/xyz/openbmc_project/sensors/energy/"
+    ]
+}
diff --git a/platform-mc/manager.hpp b/platform-mc/manager.hpp
index 7636e94..342c028 100644
--- a/platform-mc/manager.hpp
+++ b/platform-mc/manager.hpp
@@ -7,6 +7,7 @@
 #include "platform_manager.hpp"
 #include "requester/handler.hpp"
 #include "requester/mctp_endpoint_discovery.hpp"
+#include "sensor_manager.hpp"
 #include "terminus_manager.hpp"
 
 namespace pldm
@@ -33,7 +34,8 @@ class Manager : public pldm::MctpDiscoveryHandlerIntf
     explicit Manager(sdeventplus::Event& event, RequesterHandler& handler,
                      pldm::InstanceIdDb& instanceIdDb) :
         terminusManager(event, handler, instanceIdDb, termini, this),
-        platformManager(terminusManager, termini)
+        platformManager(terminusManager, termini),
+        sensorManager(event, terminusManager, termini)
     {}
 
     /** @brief Helper function to do the actions before discovering terminus
@@ -68,6 +70,20 @@ class Manager : public pldm::MctpDiscoveryHandlerIntf
         terminusManager.removeMctpTerminus(mctpInfos);
     }
 
+    /** @brief Helper function to start sensor polling of the terminus TID
+     */
+    void startSensorPolling(pldm_tid_t tid)
+    {
+        sensorManager.startPolling(tid);
+    }
+
+    /** @brief Helper function to stop sensor polling of the terminus TID
+     */
+    void stopSensorPolling(pldm_tid_t tid)
+    {
+        sensorManager.stopPolling(tid);
+    }
+
   private:
     /** @brief List of discovered termini */
     TerminiMapper termini{};
@@ -77,6 +93,9 @@ class Manager : public pldm::MctpDiscoveryHandlerIntf
 
     /** @brief Platform interface for calling the hook functions */
     PlatformManager platformManager;
+
+    /** @brief Store platform manager handler */
+    SensorManager sensorManager;
 };
 } // namespace platform_mc
 } // namespace pldm
diff --git a/platform-mc/numeric_sensor.cpp b/platform-mc/numeric_sensor.cpp
new file mode 100644
index 0000000..e438061
--- /dev/null
+++ b/platform-mc/numeric_sensor.cpp
@@ -0,0 +1,687 @@
+#include "numeric_sensor.hpp"
+
+#include "libpldm/platform.h"
+
+#include "common/utils.hpp"
+#include "requester/handler.hpp"
+
+#include <limits>
+#include <regex>
+
+PHOSPHOR_LOG2_USING;
+
+namespace pldm
+{
+namespace platform_mc
+{
+
+NumericSensor::NumericSensor(const pldm_tid_t tid, const bool sensorDisabled,
+                             std::shared_ptr<pldm_numeric_sensor_value_pdr> pdr,
+                             std::string& sensorName,
+                             std::string& associationPath) :
+    tid(tid),
+    sensorId(pdr->sensor_id), sensorName(sensorName), isPriority(false)
+{
+    std::string path;
+    SensorUnit sensorUnit = SensorUnit::DegreesC;
+
+    switch (pdr->base_unit)
+    {
+        case PLDM_SENSOR_UNIT_DEGRESS_C:
+            sensorNameSpace = "/xyz/openbmc_project/sensors/temperature/";
+            sensorUnit = SensorUnit::DegreesC;
+            break;
+        case PLDM_SENSOR_UNIT_VOLTS:
+            sensorNameSpace = "/xyz/openbmc_project/sensors/voltage/";
+            sensorUnit = SensorUnit::Volts;
+            break;
+        case PLDM_SENSOR_UNIT_AMPS:
+            sensorNameSpace = "/xyz/openbmc_project/sensors/current/";
+            sensorUnit = SensorUnit::Amperes;
+            break;
+        case PLDM_SENSOR_UNIT_RPM:
+            sensorNameSpace = "/xyz/openbmc_project/sensors/fan_pwm/";
+            sensorUnit = SensorUnit::RPMS;
+            break;
+        case PLDM_SENSOR_UNIT_WATTS:
+            sensorNameSpace = "/xyz/openbmc_project/sensors/power/";
+            sensorUnit = SensorUnit::Watts;
+            break;
+        case PLDM_SENSOR_UNIT_JOULES:
+            sensorNameSpace = "/xyz/openbmc_project/sensors/energy/";
+            sensorUnit = SensorUnit::Joules;
+            break;
+        case PLDM_SENSOR_UNIT_PERCENTAGE:
+            sensorNameSpace = "/xyz/openbmc_project/sensors/utilization/";
+            sensorUnit = SensorUnit::Percent;
+            break;
+        default:
+            lg2::error("Sensor {NAME} has Invalid baseUnit {UNIT}.", "NAME",
+                       sensorName, "UNIT", pdr->base_unit);
+            throw sdbusplus::xyz::openbmc_project::Common::Error::
+                InvalidArgument();
+            break;
+    }
+
+    path = sensorNameSpace + sensorName;
+    path = std::regex_replace(path, std::regex("[^a-zA-Z0-9_/]+"), "_");
+
+    auto& bus = pldm::utils::DBusHandler::getBus();
+    try
+    {
+        associationDefinitionsIntf =
+            std::make_unique<AssociationDefinitionsInft>(bus, path.c_str());
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        lg2::error(
+            "Failed to create association interface for numeric sensor {PATH} error - {ERROR}",
+            "PATH", path, "ERROR", e);
+        throw sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument();
+    }
+
+    associationDefinitionsIntf->associations(
+        {{"chassis", "all_sensors", associationPath.c_str()}});
+
+    double maxValue = std::numeric_limits<double>::quiet_NaN();
+    double minValue = std::numeric_limits<double>::quiet_NaN();
+
+    switch (pdr->sensor_data_size)
+    {
+        case PLDM_SENSOR_DATA_SIZE_UINT8:
+            maxValue = pdr->max_readable.value_u8;
+            minValue = pdr->min_readable.value_u8;
+            hysteresis = pdr->hysteresis.value_u8;
+            break;
+        case PLDM_SENSOR_DATA_SIZE_SINT8:
+            maxValue = pdr->max_readable.value_s8;
+            minValue = pdr->min_readable.value_s8;
+            hysteresis = pdr->hysteresis.value_s8;
+            break;
+        case PLDM_SENSOR_DATA_SIZE_UINT16:
+            maxValue = pdr->max_readable.value_u16;
+            minValue = pdr->min_readable.value_u16;
+            hysteresis = pdr->hysteresis.value_u16;
+            break;
+        case PLDM_SENSOR_DATA_SIZE_SINT16:
+            maxValue = pdr->max_readable.value_s16;
+            minValue = pdr->min_readable.value_s16;
+            hysteresis = pdr->hysteresis.value_s16;
+            break;
+        case PLDM_SENSOR_DATA_SIZE_UINT32:
+            maxValue = pdr->max_readable.value_u32;
+            minValue = pdr->min_readable.value_u32;
+            hysteresis = pdr->hysteresis.value_u32;
+            break;
+        case PLDM_SENSOR_DATA_SIZE_SINT32:
+            maxValue = pdr->max_readable.value_s32;
+            minValue = pdr->min_readable.value_s32;
+            hysteresis = pdr->hysteresis.value_s32;
+            break;
+    }
+
+    bool hasCriticalThresholds = false;
+    bool hasWarningThresholds = false;
+    double criticalHigh = std::numeric_limits<double>::quiet_NaN();
+    double criticalLow = std::numeric_limits<double>::quiet_NaN();
+    double warningHigh = std::numeric_limits<double>::quiet_NaN();
+    double warningLow = std::numeric_limits<double>::quiet_NaN();
+
+    if (pdr->supported_thresholds.bits.bit0)
+    {
+        hasWarningThresholds = true;
+        switch (pdr->range_field_format)
+        {
+            case PLDM_RANGE_FIELD_FORMAT_UINT8:
+                warningHigh = pdr->warning_high.value_u8;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_SINT8:
+                warningHigh = pdr->warning_high.value_s8;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_UINT16:
+                warningHigh = pdr->warning_high.value_u16;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_SINT16:
+                warningHigh = pdr->warning_high.value_s16;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_UINT32:
+                warningHigh = pdr->warning_high.value_u32;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_SINT32:
+                warningHigh = pdr->warning_high.value_s32;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_REAL32:
+                warningHigh = pdr->warning_high.value_f32;
+                break;
+        }
+    }
+
+    if (pdr->supported_thresholds.bits.bit3)
+    {
+        hasWarningThresholds = true;
+        switch (pdr->range_field_format)
+        {
+            case PLDM_RANGE_FIELD_FORMAT_UINT8:
+                warningLow = pdr->warning_low.value_u8;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_SINT8:
+                warningLow = pdr->warning_low.value_s8;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_UINT16:
+                warningLow = pdr->warning_low.value_u16;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_SINT16:
+                warningLow = pdr->warning_low.value_s16;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_UINT32:
+                warningLow = pdr->warning_low.value_u32;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_SINT32:
+                warningLow = pdr->warning_low.value_s32;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_REAL32:
+                warningLow = pdr->warning_low.value_f32;
+                break;
+        }
+    }
+
+    if (pdr->supported_thresholds.bits.bit1)
+    {
+        hasCriticalThresholds = true;
+        switch (pdr->range_field_format)
+        {
+            case PLDM_RANGE_FIELD_FORMAT_UINT8:
+                criticalHigh = pdr->critical_high.value_u8;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_SINT8:
+                criticalHigh = pdr->critical_high.value_s8;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_UINT16:
+                criticalHigh = pdr->critical_high.value_u16;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_SINT16:
+                criticalHigh = pdr->critical_high.value_s16;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_UINT32:
+                criticalHigh = pdr->critical_high.value_u32;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_SINT32:
+                criticalHigh = pdr->critical_high.value_s32;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_REAL32:
+                criticalHigh = pdr->critical_high.value_f32;
+                break;
+        }
+    }
+
+    if (pdr->supported_thresholds.bits.bit4)
+    {
+        hasCriticalThresholds = true;
+        switch (pdr->range_field_format)
+        {
+            case PLDM_RANGE_FIELD_FORMAT_UINT8:
+                criticalLow = pdr->critical_low.value_u8;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_SINT8:
+                criticalLow = pdr->critical_low.value_s8;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_UINT16:
+                criticalLow = pdr->critical_low.value_u16;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_SINT16:
+                criticalLow = pdr->critical_low.value_s16;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_UINT32:
+                criticalLow = pdr->critical_low.value_u32;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_SINT32:
+                criticalLow = pdr->critical_low.value_s32;
+                break;
+            case PLDM_RANGE_FIELD_FORMAT_REAL32:
+                criticalLow = pdr->critical_low.value_f32;
+                break;
+        }
+    }
+
+    resolution = pdr->resolution;
+    offset = pdr->offset;
+    baseUnitModifier = pdr->unit_modifier;
+
+    timeStamp = 0;
+    updateTime = (uint64_t)DEFAULT_SENSOR_UPDATER_INTERVAL * 1000;
+    if (!std::isnan(pdr->update_interval))
+    {
+        updateTime = pdr->update_interval * 1000000;
+    }
+
+    try
+    {
+        valueIntf = std::make_unique<ValueIntf>(bus, path.c_str());
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        lg2::error(
+            "Failed to create Value interface for numeric sensor {PATH} error - {ERROR}",
+            "PATH", path, "ERROR", e);
+        throw sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument();
+    }
+    valueIntf->maxValue(unitModifier(conversionFormula(maxValue)));
+    valueIntf->minValue(unitModifier(conversionFormula(minValue)));
+    hysteresis = unitModifier(conversionFormula(hysteresis));
+    valueIntf->unit(sensorUnit);
+
+    try
+    {
+        availabilityIntf = std::make_unique<AvailabilityIntf>(bus,
+                                                              path.c_str());
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        lg2::error(
+            "Failed to create Availability interface for numeric sensor {PATH} error - {ERROR}",
+            "PATH", path, "ERROR", e);
+        throw sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument();
+    }
+    availabilityIntf->available(true);
+
+    try
+    {
+        operationalStatusIntf =
+            std::make_unique<OperationalStatusIntf>(bus, path.c_str());
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        lg2::error(
+            "Failed to create Operation status interface for numeric sensor {PATH} error - {ERROR}",
+            "PATH", path, "ERROR", e);
+        throw sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument();
+    }
+    operationalStatusIntf->functional(!sensorDisabled);
+
+    if (hasWarningThresholds)
+    {
+        try
+        {
+            thresholdWarningIntf =
+                std::make_unique<ThresholdWarningIntf>(bus, path.c_str());
+        }
+        catch (const sdbusplus::exception_t& e)
+        {
+            lg2::error(
+                "Failed to create Threshold warning interface for numeric sensor {PATH} error - {ERROR}",
+                "PATH", path, "ERROR", e);
+            throw sdbusplus::xyz::openbmc_project::Common::Error::
+                InvalidArgument();
+        }
+        thresholdWarningIntf->warningHigh(unitModifier(warningHigh));
+        thresholdWarningIntf->warningLow(unitModifier(warningLow));
+    }
+
+    if (hasCriticalThresholds)
+    {
+        try
+        {
+            thresholdCriticalIntf =
+                std::make_unique<ThresholdCriticalIntf>(bus, path.c_str());
+        }
+        catch (const sdbusplus::exception_t& e)
+        {
+            lg2::error(
+                "Failed to create Threshold critical interface for numeric sensor {PATH} error - {ERROR}",
+                "PATH", path, "ERROR", e);
+            throw sdbusplus::xyz::openbmc_project::Common::Error::
+                InvalidArgument();
+        }
+        thresholdCriticalIntf->criticalHigh(unitModifier(criticalHigh));
+        thresholdCriticalIntf->criticalLow(unitModifier(criticalLow));
+    }
+}
+
+NumericSensor::NumericSensor(
+    const pldm_tid_t tid, const bool sensorDisabled,
+    std::shared_ptr<pldm_compact_numeric_sensor_pdr> pdr,
+    std::string& sensorName, std::string& associationPath) :
+    tid(tid),
+    sensorId(pdr->sensor_id), sensorName(sensorName), isPriority(false)
+{
+    std::string path;
+    SensorUnit sensorUnit = SensorUnit::DegreesC;
+
+    switch (pdr->base_unit)
+    {
+        case PLDM_SENSOR_UNIT_DEGRESS_C:
+            sensorNameSpace = "/xyz/openbmc_project/sensors/temperature/";
+            sensorUnit = SensorUnit::DegreesC;
+            break;
+        case PLDM_SENSOR_UNIT_VOLTS:
+            sensorNameSpace = "/xyz/openbmc_project/sensors/voltage/";
+            sensorUnit = SensorUnit::Volts;
+            break;
+        case PLDM_SENSOR_UNIT_AMPS:
+            sensorNameSpace = "/xyz/openbmc_project/sensors/current/";
+            sensorUnit = SensorUnit::Amperes;
+            break;
+        case PLDM_SENSOR_UNIT_RPM:
+            sensorNameSpace = "/xyz/openbmc_project/sensors/fan_pwm/";
+            sensorUnit = SensorUnit::RPMS;
+            break;
+        case PLDM_SENSOR_UNIT_WATTS:
+            sensorNameSpace = "/xyz/openbmc_project/sensors/power/";
+            sensorUnit = SensorUnit::Watts;
+            break;
+        case PLDM_SENSOR_UNIT_JOULES:
+            sensorNameSpace = "/xyz/openbmc_project/sensors/energy/";
+            sensorUnit = SensorUnit::Joules;
+            break;
+        case PLDM_SENSOR_UNIT_PERCENTAGE:
+            sensorNameSpace = "/xyz/openbmc_project/sensors/utilization/";
+            sensorUnit = SensorUnit::Percent;
+            break;
+        default:
+            lg2::error("Sensor {NAME} has Invalid baseUnit {UNIT}.", "NAME",
+                       sensorName, "UNIT", pdr->base_unit);
+            throw sdbusplus::xyz::openbmc_project::Common::Error::
+                InvalidArgument();
+            break;
+    }
+
+    path = sensorNameSpace + sensorName;
+    path = std::regex_replace(path, std::regex("[^a-zA-Z0-9_/]+"), "_");
+
+    auto& bus = pldm::utils::DBusHandler::getBus();
+    try
+    {
+        associationDefinitionsIntf =
+            std::make_unique<AssociationDefinitionsInft>(bus, path.c_str());
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        lg2::error(
+            "Failed to create Association interface for compact numeric sensor {PATH} error - {ERROR}",
+            "PATH", path, "ERROR", e);
+        throw sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument();
+    }
+    associationDefinitionsIntf->associations(
+        {{"chassis", "all_sensors", associationPath.c_str()}});
+
+    double maxValue = std::numeric_limits<double>::quiet_NaN();
+    double minValue = std::numeric_limits<double>::quiet_NaN();
+    bool hasWarningThresholds = false;
+    bool hasCriticalThresholds = false;
+    double criticalHigh = std::numeric_limits<double>::quiet_NaN();
+    double criticalLow = std::numeric_limits<double>::quiet_NaN();
+    double warningHigh = std::numeric_limits<double>::quiet_NaN();
+    double warningLow = std::numeric_limits<double>::quiet_NaN();
+
+    if (pdr->range_field_support.bits.bit0)
+    {
+        hasWarningThresholds = true;
+        warningHigh = pdr->warning_high;
+    }
+    if (pdr->range_field_support.bits.bit1)
+    {
+        hasWarningThresholds = true;
+        warningLow = pdr->warning_low;
+    }
+
+    if (pdr->range_field_support.bits.bit2)
+    {
+        hasCriticalThresholds = true;
+        criticalHigh = pdr->critical_high;
+    }
+
+    if (pdr->range_field_support.bits.bit3)
+    {
+        hasCriticalThresholds = true;
+        criticalLow = pdr->critical_low;
+    }
+
+    resolution = std::numeric_limits<double>::quiet_NaN();
+    offset = std::numeric_limits<double>::quiet_NaN();
+    baseUnitModifier = pdr->unit_modifier;
+
+    timeStamp = 0;
+    updateTime = (uint64_t)DEFAULT_SENSOR_UPDATER_INTERVAL * 1000;
+    try
+    {
+        valueIntf = std::make_unique<ValueIntf>(bus, path.c_str());
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        lg2::error(
+            "Failed to create Value interface for compact numeric sensor {PATH} error - {ERROR}",
+            "PATH", path, "ERROR", e);
+        throw sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument();
+    }
+    valueIntf->maxValue(unitModifier(conversionFormula(maxValue)));
+    valueIntf->minValue(unitModifier(conversionFormula(minValue)));
+    hysteresis = unitModifier(conversionFormula(hysteresis));
+    valueIntf->unit(sensorUnit);
+
+    try
+    {
+        availabilityIntf = std::make_unique<AvailabilityIntf>(bus,
+                                                              path.c_str());
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        lg2::error(
+            "Failed to create Availability interface for compact numeric sensor {PATH} error - {ERROR}",
+            "PATH", path, "ERROR", e);
+        throw sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument();
+    }
+    availabilityIntf->available(true);
+
+    try
+    {
+        operationalStatusIntf =
+            std::make_unique<OperationalStatusIntf>(bus, path.c_str());
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        lg2::error(
+            "Failed to create Operational status interface for compact numeric sensor {PATH} error - {ERROR}",
+            "PATH", path, "ERROR", e);
+        throw sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument();
+    }
+    operationalStatusIntf->functional(!sensorDisabled);
+
+    if (hasWarningThresholds)
+    {
+        try
+        {
+            thresholdWarningIntf =
+                std::make_unique<ThresholdWarningIntf>(bus, path.c_str());
+        }
+        catch (const sdbusplus::exception_t& e)
+        {
+            lg2::error(
+                "Failed to create Warning threshold interface for compact numeric sensor {PATH} error - {ERROR}",
+                "PATH", path, "ERROR", e);
+            throw sdbusplus::xyz::openbmc_project::Common::Error::
+                InvalidArgument();
+        }
+        thresholdWarningIntf->warningHigh(unitModifier(warningHigh));
+        thresholdWarningIntf->warningLow(unitModifier(warningLow));
+    }
+
+    if (hasCriticalThresholds)
+    {
+        try
+        {
+            thresholdCriticalIntf =
+                std::make_unique<ThresholdCriticalIntf>(bus, path.c_str());
+        }
+        catch (const sdbusplus::exception_t& e)
+        {
+            lg2::error(
+                "Failed to create Critical threshold interface for compact numeric sensor {PATH} error - {ERROR}",
+                "PATH", path, "ERROR", e);
+            throw sdbusplus::xyz::openbmc_project::Common::Error::
+                InvalidArgument();
+        }
+        thresholdCriticalIntf->criticalHigh(unitModifier(criticalHigh));
+        thresholdCriticalIntf->criticalLow(unitModifier(criticalLow));
+    }
+}
+
+double NumericSensor::conversionFormula(double value)
+{
+    double convertedValue = value;
+    convertedValue *= std::isnan(resolution) ? 1 : resolution;
+    convertedValue += std::isnan(offset) ? 0 : offset;
+    return convertedValue;
+}
+
+double NumericSensor::unitModifier(double value)
+{
+    return std::isnan(value) ? value : value * std::pow(10, baseUnitModifier);
+}
+
+void NumericSensor::updateReading(bool available, bool functional, double value)
+{
+    availabilityIntf->available(available);
+    operationalStatusIntf->functional(functional);
+    double curValue = valueIntf->value();
+    double newValue = std::numeric_limits<double>::quiet_NaN();
+    if (functional && available)
+    {
+        newValue = unitModifier(conversionFormula(value));
+        if (curValue != newValue)
+        {
+            valueIntf->value(unitModifier(conversionFormula(value)));
+            updateThresholds();
+        }
+    }
+    else
+    {
+        if (curValue != newValue)
+        {
+            valueIntf->value(std::numeric_limits<double>::quiet_NaN());
+        }
+    }
+}
+
+void NumericSensor::handleErrGetSensorReading()
+{
+    operationalStatusIntf->functional(false);
+    valueIntf->value(std::numeric_limits<double>::quiet_NaN());
+}
+
+bool NumericSensor::checkThreshold(bool alarm, bool direction, double value,
+                                   double threshold, double hyst)
+{
+    if (direction)
+    {
+        if (value >= threshold)
+        {
+            return true;
+        }
+        else if (value < (threshold - hyst))
+        {
+            return false;
+        }
+    }
+    else
+    {
+        if (value <= threshold)
+        {
+            return true;
+        }
+        else if (value > (threshold + hyst))
+        {
+            return false;
+        }
+    }
+    return alarm;
+}
+
+void NumericSensor::updateThresholds()
+{
+    auto value = valueIntf->value();
+
+    if (thresholdWarningIntf &&
+        !std::isnan(thresholdWarningIntf->warningHigh()))
+    {
+        auto threshold = thresholdWarningIntf->warningHigh();
+        auto alarm = thresholdWarningIntf->warningAlarmHigh();
+        auto newAlarm = checkThreshold(alarm, true, value, threshold,
+                                       hysteresis);
+        if (alarm != newAlarm)
+        {
+            thresholdWarningIntf->warningAlarmHigh(newAlarm);
+            if (newAlarm)
+            {
+                thresholdWarningIntf->warningHighAlarmAsserted(value);
+            }
+            else
+            {
+                thresholdWarningIntf->warningHighAlarmDeasserted(value);
+            }
+        }
+    }
+
+    if (thresholdWarningIntf && !std::isnan(thresholdWarningIntf->warningLow()))
+    {
+        auto threshold = thresholdWarningIntf->warningLow();
+        auto alarm = thresholdWarningIntf->warningAlarmLow();
+        auto newAlarm = checkThreshold(alarm, false, value, threshold,
+                                       hysteresis);
+        if (alarm != newAlarm)
+        {
+            thresholdWarningIntf->warningAlarmLow(newAlarm);
+            if (newAlarm)
+            {
+                thresholdWarningIntf->warningLowAlarmAsserted(value);
+            }
+            else
+            {
+                thresholdWarningIntf->warningLowAlarmDeasserted(value);
+            }
+        }
+    }
+
+    if (thresholdCriticalIntf &&
+        !std::isnan(thresholdCriticalIntf->criticalHigh()))
+    {
+        auto threshold = thresholdCriticalIntf->criticalHigh();
+        auto alarm = thresholdCriticalIntf->criticalAlarmHigh();
+        auto newAlarm = checkThreshold(alarm, true, value, threshold,
+                                       hysteresis);
+        if (alarm != newAlarm)
+        {
+            thresholdCriticalIntf->criticalAlarmHigh(newAlarm);
+            if (newAlarm)
+            {
+                thresholdCriticalIntf->criticalHighAlarmAsserted(value);
+            }
+            else
+            {
+                thresholdCriticalIntf->criticalHighAlarmDeasserted(value);
+            }
+        }
+    }
+
+    if (thresholdCriticalIntf &&
+        !std::isnan(thresholdCriticalIntf->criticalLow()))
+    {
+        auto threshold = thresholdCriticalIntf->criticalLow();
+        auto alarm = thresholdCriticalIntf->criticalAlarmLow();
+        auto newAlarm = checkThreshold(alarm, false, value, threshold,
+                                       hysteresis);
+        if (alarm != newAlarm)
+        {
+            thresholdCriticalIntf->criticalAlarmLow(newAlarm);
+            if (newAlarm)
+            {
+                thresholdCriticalIntf->criticalLowAlarmAsserted(value);
+            }
+            else
+            {
+                thresholdCriticalIntf->criticalLowAlarmDeasserted(value);
+            }
+        }
+    }
+}
+} // namespace platform_mc
+} // namespace pldm
diff --git a/platform-mc/numeric_sensor.hpp b/platform-mc/numeric_sensor.hpp
new file mode 100644
index 0000000..ff9e286
--- /dev/null
+++ b/platform-mc/numeric_sensor.hpp
@@ -0,0 +1,219 @@
+#pragma once
+
+#include "libpldm/platform.h"
+#include "libpldm/pldm.h"
+
+#include "common/types.hpp"
+
+#include <sdbusplus/server/object.hpp>
+#include <xyz/openbmc_project/Association/Definitions/server.hpp>
+#include <xyz/openbmc_project/Sensor/Threshold/Critical/server.hpp>
+#include <xyz/openbmc_project/Sensor/Threshold/Warning/server.hpp>
+#include <xyz/openbmc_project/Sensor/Value/server.hpp>
+#include <xyz/openbmc_project/State/Decorator/Availability/server.hpp>
+#include <xyz/openbmc_project/State/Decorator/OperationalStatus/server.hpp>
+
+#include <string>
+
+namespace pldm
+{
+namespace platform_mc
+{
+
+using SensorUnit = sdbusplus::xyz::openbmc_project::Sensor::server::Value::Unit;
+using ValueIntf = sdbusplus::server::object_t<
+    sdbusplus::xyz::openbmc_project::Sensor::server::Value>;
+using ThresholdWarningIntf = sdbusplus::server::object_t<
+    sdbusplus::xyz::openbmc_project::Sensor::Threshold::server::Warning>;
+using ThresholdCriticalIntf = sdbusplus::server::object_t<
+    sdbusplus::xyz::openbmc_project::Sensor::Threshold::server::Critical>;
+using OperationalStatusIntf =
+    sdbusplus::server::object_t<sdbusplus::xyz::openbmc_project::State::
+                                    Decorator::server::OperationalStatus>;
+using AvailabilityIntf = sdbusplus::server::object_t<
+    sdbusplus::xyz::openbmc_project::State::Decorator::server::Availability>;
+using AssociationDefinitionsInft = sdbusplus::server::object_t<
+    sdbusplus::xyz::openbmc_project::Association::server::Definitions>;
+
+/**
+ * @brief NumericSensor
+ *
+ * This class handles sensor reading updated by sensor manager and export
+ * status to D-Bus interface.
+ */
+class NumericSensor
+{
+  public:
+    NumericSensor(const pldm_tid_t tid, const bool sensorDisabled,
+                  std::shared_ptr<pldm_numeric_sensor_value_pdr> pdr,
+                  std::string& sensorName, std::string& associationPath);
+
+    NumericSensor(const pldm_tid_t tid, const bool sensorDisabled,
+                  std::shared_ptr<pldm_compact_numeric_sensor_pdr> pdr,
+                  std::string& sensorName, std::string& associationPath);
+
+    ~NumericSensor(){};
+
+    /** @brief The function called by Sensor Manager to set sensor to
+     * error status.
+     */
+    void handleErrGetSensorReading();
+
+    /** @brief Updating the sensor status to D-Bus interface
+     */
+    void updateReading(bool available, bool functional, double value = 0);
+
+    /** @brief ConversionFormula is used to convert raw value to the unit
+     * specified in PDR
+     *
+     *  @param[in] value - raw value
+     *  @return double - converted value
+     */
+    double conversionFormula(double value);
+
+    /** @brief UnitModifier is used to apply the unit modifier specified in PDR
+     *
+     *  @param[in] value - raw value
+     *  @return double - converted value
+     */
+    double unitModifier(double value);
+
+    /** @brief Check if value is over threshold.
+     *
+     *  @param[in] alarm - previous alarm state
+     *  @param[in] direction - upper or lower threshold checking
+     *  @param[in] value - raw value
+     *  @param[in] threshold - threshold value
+     *  @param[in] hyst - hysteresis value
+     *  @return bool - new alarm state
+     */
+    bool checkThreshold(bool alarm, bool direction, double value,
+                        double threshold, double hyst);
+
+    /** @brief Updating the association to D-Bus interface
+     *  @param[in] inventoryPath - inventory path of the entity
+     */
+    inline void setInventoryPath(const std::string& inventoryPath)
+    {
+        if (associationDefinitionsIntf)
+        {
+            associationDefinitionsIntf->associations(
+                {{"chassis", "all_sensors", inventoryPath.c_str()}});
+        }
+    }
+
+    /** @brief Get Upper Critical threshold
+     *
+     *  @return double - Upper Critical threshold
+     */
+    double getThresholdUpperCritical()
+    {
+        if (thresholdCriticalIntf)
+        {
+            return thresholdCriticalIntf->criticalHigh();
+        }
+        else
+        {
+            return std::numeric_limits<double>::quiet_NaN();
+        }
+    };
+
+    /** @brief Get Lower Critical threshold
+     *
+     *  @return double - Lower Critical threshold
+     */
+    double getThresholdLowerCritical()
+    {
+        if (thresholdCriticalIntf)
+        {
+            return thresholdCriticalIntf->criticalLow();
+        }
+        else
+        {
+            return std::numeric_limits<double>::quiet_NaN();
+        }
+    };
+
+    /** @brief Get Upper Warning threshold
+     *
+     *  @return double - Upper Warning threshold
+     */
+    double getThresholdUpperWarning()
+    {
+        if (thresholdWarningIntf)
+        {
+            return thresholdWarningIntf->warningHigh();
+        }
+        else
+        {
+            return std::numeric_limits<double>::quiet_NaN();
+        }
+    };
+
+    /** @brief Get Lower Warning threshold
+     *
+     *  @return double - Lower Warning threshold
+     */
+    double getThresholdLowerWarning()
+    {
+        if (thresholdWarningIntf)
+        {
+            return thresholdWarningIntf->warningLow();
+        }
+        else
+        {
+            return std::numeric_limits<double>::quiet_NaN();
+        }
+    };
+
+    /** @brief Terminus ID which the sensor belongs to */
+    pldm_tid_t tid;
+
+    /** @brief Sensor ID */
+    uint16_t sensorId;
+
+    /** @brief  The time stamp since last getSensorReading command in usec */
+    uint64_t timeStamp;
+
+    /** @brief  The time of sensor update interval in usec */
+    uint64_t updateTime;
+
+    /** @brief  sensorName */
+    std::string sensorName;
+
+    /** @brief  sensorNameSpace */
+    std::string sensorNameSpace;
+
+    /** @brief indicate if sensor is polled in priority */
+    bool isPriority;
+
+  private:
+    /**
+     * @brief Check sensor reading if any threshold has been crossed and update
+     * Threshold interfaces accordingly
+     */
+    void updateThresholds();
+
+    std::unique_ptr<ValueIntf> valueIntf = nullptr;
+    std::unique_ptr<ThresholdWarningIntf> thresholdWarningIntf = nullptr;
+    std::unique_ptr<ThresholdCriticalIntf> thresholdCriticalIntf = nullptr;
+    std::unique_ptr<AvailabilityIntf> availabilityIntf = nullptr;
+    std::unique_ptr<OperationalStatusIntf> operationalStatusIntf = nullptr;
+    std::unique_ptr<AssociationDefinitionsInft> associationDefinitionsIntf =
+        nullptr;
+
+    /** @brief Amount of hysteresis associated with the sensor thresholds */
+    double hysteresis;
+
+    /** @brief The resolution of sensor in Units */
+    double resolution;
+
+    /** @brief A constant value that is added in as part of conversion process
+     * of converting a raw sensor reading to Units */
+    double offset;
+
+    /** @brief A power-of-10 multiplier for baseUnit */
+    int8_t baseUnitModifier;
+};
+} // namespace platform_mc
+} // namespace pldm
diff --git a/platform-mc/sensor_manager.cpp b/platform-mc/sensor_manager.cpp
new file mode 100644
index 0000000..97fbf1d
--- /dev/null
+++ b/platform-mc/sensor_manager.cpp
@@ -0,0 +1,410 @@
+#include "sensor_manager.hpp"
+
+#include "terminus_manager.hpp"
+
+#include <phosphor-logging/lg2.hpp>
+
+#include <exception>
+
+namespace pldm
+{
+namespace platform_mc
+{
+
+SensorManager::SensorManager(sdeventplus::Event& event,
+                             TerminusManager& terminusManager,
+                             TerminiMapper& termini, bool verbose,
+                             const std::filesystem::path& configJson) :
+    event(event),
+    terminusManager(terminusManager), termini(termini),
+    pollingTime(SENSOR_POLLING_TIME), verbose(verbose)
+{
+    // default priority sensor name spaces
+    prioritySensorNameSpaces.emplace_back(
+        "/xyz/openbmc_project/sensors/temperature/");
+    prioritySensorNameSpaces.emplace_back(
+        "/xyz/openbmc_project/sensors/power/");
+    prioritySensorNameSpaces.emplace_back(
+        "/xyz/openbmc_project/sensors/energy/");
+
+    if (!std::filesystem::exists(configJson))
+    {
+        return;
+    }
+
+    std::ifstream jsonFile(configJson);
+    auto data = nlohmann::json::parse(jsonFile, nullptr, false);
+    if (data.is_discarded())
+    {
+        lg2::error("Parsing json file failed. File path {FILE_PATH}",
+                   "FILE_PATH", std::string(configJson));
+        return;
+    }
+
+    // load priority sensor name spaces
+    const std::vector<std::string> emptyStringArray{};
+    auto nameSpaces = data.value("PrioritySensorNameSpaces", emptyStringArray);
+    if (nameSpaces.size() > 0)
+    {
+        prioritySensorNameSpaces.clear();
+        for (const auto& nameSpace : nameSpaces)
+        {
+            prioritySensorNameSpaces.emplace_back(nameSpace);
+        }
+    }
+}
+
+bool SensorManager::isPriority(std::shared_ptr<NumericSensor> sensor)
+{
+    return (std::find(prioritySensorNameSpaces.begin(),
+                      prioritySensorNameSpaces.end(),
+                      sensor->sensorNameSpace) !=
+            prioritySensorNameSpaces.end());
+}
+
+void SensorManager::startPolling(pldm_tid_t tid)
+{
+    // initialize prioritySensors and roundRobinSensors list
+    if (!termini.contains(tid))
+    {
+        return;
+    }
+    /* tid already initialize prioritySensors and roundRobinSensors list */
+    if (sensorPollTimers.contains(tid))
+    {
+        lg2::info("Terminus ID {TID}: sensor poll timer already exists.", "TID",
+                  tid);
+        return;
+    }
+    // numeric sensor
+    auto terminus = termini[tid];
+    for (auto& sensor : terminus->numericSensors)
+    {
+        if (isPriority(sensor))
+        {
+            sensor->isPriority = true;
+            prioritySensors[tid].emplace_back(sensor);
+        }
+        else
+        {
+            sensor->isPriority = false;
+            roundRobinSensors[tid].push(sensor);
+        }
+    }
+
+    if ((prioritySensors[tid].size() == 0) &&
+        (roundRobinSensors[tid].size() == 0))
+    {
+        lg2::info("Terminus ID {TID}: no sensor to polling.", "TID", tid);
+        return;
+    }
+
+    if (!sensorPollTimers.contains(tid))
+    {
+        sensorPollTimers[tid] = std::make_unique<sdbusplus::Timer>(
+            event.get(),
+            std::bind_front(&SensorManager::doSensorPolling, this, tid));
+    }
+
+    if (!sensorPollTimers[tid]->isRunning())
+    {
+        sensorPollTimers[tid]->start(
+            duration_cast<std::chrono::milliseconds>(
+                std::chrono::milliseconds(pollingTime)),
+            true);
+    }
+}
+
+void SensorManager::stopPolling(pldm_tid_t tid)
+{
+    /* Stop polling timer */
+    if (sensorPollTimers.contains(tid))
+    {
+        sensorPollTimers[tid]->stop();
+        sensorPollTimers.erase(tid);
+    }
+
+    if (prioritySensors.contains(tid))
+    {
+        prioritySensors[tid].clear();
+        prioritySensors.erase(tid);
+    }
+
+    if (roundRobinSensors.contains(tid))
+    {
+        while (!roundRobinSensors[tid].empty())
+        {
+            roundRobinSensors[tid].pop();
+        }
+        roundRobinSensors.erase(tid);
+    }
+
+    if (doSensorPollingTaskHandles.contains(tid))
+    {
+        auto& [scope, rcOpt] = doSensorPollingTaskHandles[tid];
+        scope.request_stop();
+        stdexec::sync_wait(scope.on_empty());
+        doSensorPollingTaskHandles.erase(tid);
+    }
+}
+
+void SensorManager::doSensorPolling(pldm_tid_t tid)
+{
+    if (auto it = doSensorPollingTaskHandles.find(tid);
+        it != doSensorPollingTaskHandles.end())
+    {
+        auto& [scope, rcOpt] = it->second;
+        if (!rcOpt.has_value())
+        {
+            return;
+        }
+        stdexec::sync_wait(scope.on_empty());
+        doSensorPollingTaskHandles.erase(tid);
+    }
+
+    auto& [scope, rcOpt] = doSensorPollingTaskHandles
+                               .emplace(std::piecewise_construct,
+                                        std::forward_as_tuple(tid),
+                                        std::forward_as_tuple())
+                               .first->second;
+    scope.spawn(stdexec::just() |
+                    stdexec::let_value([this, &rcOpt, tid] -> exec::task<void> {
+        auto res =
+            co_await stdexec::stopped_as_optional(doSensorPollingTask(tid));
+        if (res.has_value())
+        {
+            rcOpt = *res;
+        }
+        else
+        {
+            lg2::info("Stopped sensor polling for Terminus ID {TID}", "TID",
+                      tid);
+            rcOpt = PLDM_SUCCESS;
+        }
+    }),
+                exec::default_task_context<void>());
+}
+
+exec::task<int> SensorManager::doSensorPollingTask(pldm_tid_t tid)
+{
+    uint64_t t0 = 0;
+    uint64_t t1 = 0;
+    uint64_t elapsed = 0;
+    uint64_t pollingTimeInUsec = pollingTime * 1000;
+    uint8_t rc = PLDM_SUCCESS;
+
+    do
+    {
+        if ((!sensorPollTimers.contains(tid)) ||
+            (sensorPollTimers[tid] && !sensorPollTimers[tid]->isRunning()))
+        {
+            co_return PLDM_ERROR;
+        }
+
+        sd_event_now(event.get(), CLOCK_MONOTONIC, &t0);
+        if (verbose)
+        {
+            lg2::info("Terminus ID {TID}: start sensor polling at {NOW}.",
+                      "TID", tid, "NOW", pldm::utils::getCurrentSystemTime());
+        }
+
+        if (!termini.contains(tid))
+        {
+            co_return PLDM_SUCCESS;
+        }
+
+        // poll priority Sensors
+        for (auto& sensor : prioritySensors[tid])
+        {
+            if (sensor->updateTime == std::numeric_limits<uint64_t>::max())
+            {
+                continue;
+            }
+
+            sd_event_now(event.get(), CLOCK_MONOTONIC, &t1);
+            elapsed = t1 - sensor->timeStamp;
+            if (sensor->updateTime <= elapsed)
+            {
+                rc = co_await getSensorReading(sensor);
+
+                if ((!sensorPollTimers.contains(tid)) ||
+                    (sensorPollTimers[tid] &&
+                     !sensorPollTimers[tid]->isRunning()))
+                {
+                    co_return PLDM_ERROR;
+                }
+                sd_event_now(event.get(), CLOCK_MONOTONIC, &t1);
+                if (rc == PLDM_SUCCESS)
+                {
+                    sensor->timeStamp = t1;
+                }
+            }
+        }
+
+        // poll roundRobin Sensors
+        sd_event_now(event.get(), CLOCK_MONOTONIC, &t1);
+        auto toBeUpdated = roundRobinSensors[tid].size();
+        while (((t1 - t0) < pollingTimeInUsec) && (toBeUpdated > 0))
+        {
+            auto sensor = roundRobinSensors[tid].front();
+
+            sd_event_now(event.get(), CLOCK_MONOTONIC, &t1);
+            elapsed = t1 - sensor->timeStamp;
+            if (sensor->updateTime <= elapsed)
+            {
+                rc = co_await getSensorReading(sensor);
+
+                if ((!sensorPollTimers.contains(tid)) ||
+                    (sensorPollTimers[tid] &&
+                     !sensorPollTimers[tid]->isRunning()))
+                {
+                    co_return PLDM_ERROR;
+                }
+                sd_event_now(event.get(), CLOCK_MONOTONIC, &t1);
+                if (rc == PLDM_SUCCESS)
+                {
+                    sensor->timeStamp = t1;
+                }
+                else
+                {
+                    lg2::error(
+                        "Failed to get sensor value for terminus {TID}, error: {RC}",
+                        "TID", tid, "RC", rc);
+                }
+            }
+
+            toBeUpdated--;
+            if (roundRobinSensors.contains(tid))
+            {
+                roundRobinSensors[tid].pop();
+                roundRobinSensors[tid].push(std::move(sensor));
+            }
+            sd_event_now(event.get(), CLOCK_MONOTONIC, &t1);
+        }
+
+        if (verbose)
+        {
+            sd_event_now(event.get(), CLOCK_MONOTONIC, &t1);
+            lg2::info("end sensor polling at '{END}'. duration(us):'{DELTA}'",
+                      "END", pldm::utils::getCurrentSystemTime(), "DELTA",
+                      t1 - t0);
+        }
+
+        sd_event_now(event.get(), CLOCK_MONOTONIC, &t1);
+    } while ((t1 - t0) >= pollingTimeInUsec);
+
+    co_return PLDM_SUCCESS;
+}
+
+exec::task<int>
+    SensorManager::getSensorReading(std::shared_ptr<NumericSensor> sensor)
+{
+    auto tid = sensor->tid;
+    auto sensorId = sensor->sensorId;
+    Request request(sizeof(pldm_msg_hdr) + PLDM_GET_SENSOR_READING_REQ_BYTES);
+    auto requestMsg = reinterpret_cast<pldm_msg*>(request.data());
+    auto rc = encode_get_sensor_reading_req(0, sensorId, false, requestMsg);
+    if (rc)
+    {
+        lg2::error(
+            "Failed to encode request GetSensorReading for terminus ID {TID}, sensor Id {ID}, error {RC}.",
+            "TID", tid, "ID", sensorId, "RC", rc);
+        co_return rc;
+    }
+
+    const pldm_msg* responseMsg = nullptr;
+    size_t responseLen = 0;
+    rc = co_await terminusManager.sendRecvPldmMsg(tid, request, &responseMsg,
+                                                  &responseLen);
+    if (rc)
+    {
+        lg2::error(
+            "Failed to send GetSensorReading message for terminus {TID}, sensor Id {ID}, error {RC}",
+            "TID", tid, "ID", sensorId, "RC", rc);
+        co_return rc;
+    }
+
+    if ((!sensorPollTimers.contains(tid)) ||
+        (sensorPollTimers[tid] && !sensorPollTimers[tid]->isRunning()))
+    {
+        co_return PLDM_ERROR;
+    }
+
+    uint8_t completionCode = PLDM_SUCCESS;
+    uint8_t sensorDataSize = PLDM_SENSOR_DATA_SIZE_SINT32;
+    uint8_t sensorOperationalState = 0;
+    uint8_t sensorEventMessageEnable = 0;
+    uint8_t presentState = 0;
+    uint8_t previousState = 0;
+    uint8_t eventState = 0;
+    union_sensor_data_size presentReading;
+    rc = decode_get_sensor_reading_resp(
+        responseMsg, responseLen, &completionCode, &sensorDataSize,
+        &sensorOperationalState, &sensorEventMessageEnable, &presentState,
+        &previousState, &eventState,
+        reinterpret_cast<uint8_t*>(&presentReading));
+    if (rc)
+    {
+        lg2::error(
+            "Failed to decode response GetSensorReading for terminus ID {TID}, sensor Id {ID}, error {RC}.",
+            "TID", tid, "ID", sensorId, "RC", rc);
+        sensor->handleErrGetSensorReading();
+        co_return rc;
+    }
+
+    if (completionCode != PLDM_SUCCESS)
+    {
+        lg2::error(
+            "Error : GetSensorReading for terminus ID {TID}, sensor Id {ID}, complete code {CC}.",
+            "TID", tid, "ID", sensorId, "CC", completionCode);
+        co_return completionCode;
+    }
+
+    double value = std::numeric_limits<double>::quiet_NaN();
+    switch (sensorOperationalState)
+    {
+        case PLDM_SENSOR_ENABLED:
+            break;
+        case PLDM_SENSOR_DISABLED:
+            sensor->updateReading(true, false, value);
+            co_return completionCode;
+        case PLDM_SENSOR_FAILED:
+            sensor->updateReading(false, true, value);
+            co_return completionCode;
+        case PLDM_SENSOR_UNAVAILABLE:
+        default:
+            sensor->updateReading(false, false, value);
+            co_return completionCode;
+    }
+
+    switch (sensorDataSize)
+    {
+        case PLDM_SENSOR_DATA_SIZE_UINT8:
+            value = static_cast<double>(presentReading.value_u8);
+            break;
+        case PLDM_SENSOR_DATA_SIZE_SINT8:
+            value = static_cast<double>(presentReading.value_s8);
+            break;
+        case PLDM_SENSOR_DATA_SIZE_UINT16:
+            value = static_cast<double>(presentReading.value_u16);
+            break;
+        case PLDM_SENSOR_DATA_SIZE_SINT16:
+            value = static_cast<double>(presentReading.value_s16);
+            break;
+        case PLDM_SENSOR_DATA_SIZE_UINT32:
+            value = static_cast<double>(presentReading.value_u32);
+            break;
+        case PLDM_SENSOR_DATA_SIZE_SINT32:
+            value = static_cast<double>(presentReading.value_s32);
+            break;
+        default:
+            value = std::numeric_limits<double>::quiet_NaN();
+            break;
+    }
+
+    sensor->updateReading(true, true, value);
+    co_return completionCode;
+}
+
+} // namespace platform_mc
+} // namespace pldm
diff --git a/platform-mc/sensor_manager.hpp b/platform-mc/sensor_manager.hpp
new file mode 100644
index 0000000..861a3d4
--- /dev/null
+++ b/platform-mc/sensor_manager.hpp
@@ -0,0 +1,117 @@
+#pragma once
+
+#include "libpldm/platform.h"
+#include "libpldm/pldm.h"
+
+#include "common/types.hpp"
+#include "requester/handler.hpp"
+#include "terminus.hpp"
+#include "terminus_manager.hpp"
+
+#include <map>
+#include <memory>
+#include <optional>
+#include <utility>
+#include <vector>
+
+namespace pldm
+{
+namespace platform_mc
+{
+
+/**
+ * @brief SensorManager
+ *
+ * This class manages the sensors found in terminus and provides
+ * function calls for other classes to start/stop sensor monitoring.
+ *
+ */
+class SensorManager
+{
+  public:
+    SensorManager() = delete;
+    SensorManager(const SensorManager&) = delete;
+    SensorManager(SensorManager&&) = delete;
+    SensorManager& operator=(const SensorManager&) = delete;
+    SensorManager& operator=(SensorManager&&) = delete;
+    virtual ~SensorManager() = default;
+
+    explicit SensorManager(
+        sdeventplus::Event& event, TerminusManager& terminusManager,
+        TerminiMapper& termini, bool verbose = false,
+        const std::filesystem::path& configJson = PLDM_T2_CONFIG_JSON);
+
+    /** @brief starting sensor polling task
+     */
+    void startPolling(pldm_tid_t tid);
+
+    /** @brief stopping sensor polling task
+     */
+    void stopPolling(pldm_tid_t tid);
+
+  protected:
+    /** @brief start a coroutine for polling all sensors.
+     */
+    virtual void doSensorPolling(pldm_tid_t tid);
+
+    /** @brief polling all sensors in each terminus
+     *
+     *  @param[in] tid - Destination TID
+     *  @return coroutine return_value - PLDM completion code
+     */
+    exec::task<int> doSensorPollingTask(pldm_tid_t tid);
+
+    /** @brief Sending getSensorReading command for the sensor
+     *
+     *  @param[in] sensor - the sensor to be updated
+     *  @return coroutine return_value - PLDM completion code
+     */
+    exec::task<int> getSensorReading(std::shared_ptr<NumericSensor> sensor);
+
+    /** @brief check if numeric sensor is in priority name spaces
+     *
+     *  @param[in] sensor - the sensor to be checked
+     *
+     *  @return bool - true:is in priority
+     */
+    bool isPriority(std::shared_ptr<NumericSensor> sensor);
+
+    /** @brief Reference to to PLDM daemon's main event loop.
+     */
+    sdeventplus::Event& event;
+
+    /** @brief reference of terminusManager */
+    TerminusManager& terminusManager;
+
+    /** @brief List of discovered termini */
+    TerminiMapper& termini;
+
+    /** @brief sensor polling interval in ms. */
+    uint32_t pollingTime;
+
+    /** @brief sensor polling timers */
+    std::map<pldm_tid_t, std::unique_ptr<sdbusplus::Timer>> sensorPollTimers;
+
+    /** @brief coroutine handle of doSensorPollingTasks */
+    std::map<pldm_tid_t, std::pair<exec::async_scope, std::optional<int>>>
+        doSensorPollingTaskHandles;
+
+    /** @brief force stop polling sensors*/
+    bool forceStopPolling = false;
+
+    /** @brief verbose tracing flag */
+    bool verbose;
+
+    /** @brief priority SensorNameSpace list */
+    std::vector<std::string> prioritySensorNameSpaces;
+
+    /** @brief priority sensor list */
+    std::map<pldm_tid_t, std::vector<std::shared_ptr<NumericSensor>>>
+        prioritySensors;
+
+    /** @brief round robin sensor list */
+    std::map<pldm_tid_t, std::queue<std::shared_ptr<NumericSensor>>>
+        roundRobinSensors;
+};
+} // namespace platform_mc
+} // namespace pldm
diff --git a/platform-mc/terminus.cpp b/platform-mc/terminus.cpp
index 333813e..95caa40 100644
--- a/platform-mc/terminus.cpp
+++ b/platform-mc/terminus.cpp
@@ -11,7 +11,22 @@ namespace platform_mc
 
 Terminus::Terminus(pldm_tid_t tid, uint64_t supportedTypes) :
     initialized(false), tid(tid), supportedTypes(supportedTypes)
-{}
+{
+    inventoryPath = "/xyz/openbmc_project/inventory/Item/Board/PLDM_Device_" +
+                    std::to_string(tid);
+    try
+    {
+        inventoryItemBoardInft = std::make_unique<InventoryItemBoardIntf>(
+            utils::DBusHandler::getBus(), inventoryPath.c_str());
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        lg2::error(
+            "Failed to create Inventory Board interface for device {PATH}",
+            "PATH", inventoryPath);
+        throw sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument();
+    }
+}
 
 bool Terminus::doesSupportType(uint8_t type)
 {
@@ -95,6 +110,17 @@ bool Terminus::parsePDRs()
             rc = false;
         }
     }
+
+    for (auto pdr : numericSensorPdrs)
+    {
+        addNumericSensor(pdr);
+    }
+
+    for (auto pdr : compactNumericSensorPdrs)
+    {
+        addCompactNumericSensor(pdr);
+    }
+
     return rc;
 }
 
@@ -169,11 +195,56 @@ std::shared_ptr<pldm_numeric_sensor_value_pdr>
     auto rc = decode_numeric_sensor_pdr_data(ptr, pdr.size(), parsedPdr.get());
     if (rc)
     {
+        lg2::error("Failed to decode Numeric Sensor PDR data, error {RC} ",
+                   "RC", rc);
         return nullptr;
     }
     return parsedPdr;
 }
 
+void Terminus::addNumericSensor(
+    const std::shared_ptr<pldm_numeric_sensor_value_pdr> pdr)
+{
+    uint16_t sensorId = pdr->sensor_id;
+    std::string sensorName = "PLDM_Device_" + std::to_string(sensorId) + "_" +
+                             std::to_string(tid);
+
+    if (pdr->sensor_auxiliary_names_pdr)
+    {
+        auto sensorAuxiliaryNames = getSensorAuxiliaryNames(sensorId);
+        if (sensorAuxiliaryNames)
+        {
+            const auto& [sensorId, sensorCnt,
+                         sensorNames] = *sensorAuxiliaryNames;
+            if (sensorCnt == 1)
+            {
+                for (const auto& [languageTag, name] : sensorNames[0])
+                {
+                    if (languageTag == "en")
+                    {
+                        sensorName = name + "_" + std::to_string(sensorId) +
+                                     "_" + std::to_string(tid);
+                    }
+                }
+            }
+        }
+    }
+
+    try
+    {
+        auto sensor = std::make_shared<NumericSensor>(
+            tid, true, pdr, sensorName, inventoryPath);
+        lg2::info("Created NumericSensor {NAME}", "NAME", sensorName);
+        numericSensors.emplace_back(sensor);
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        lg2::error(
+            "Failed to create NumericSensor. error - {ERROR} sensorname - {NAME}",
+            "ERROR", e, "NAME", sensorName);
+    }
+}
+
 std::shared_ptr<SensorAuxiliaryNames>
     Terminus::parseCompactNumericSensorNames(const std::vector<uint8_t>& sPdr)
 {
@@ -247,5 +318,46 @@ std::shared_ptr<pldm_compact_numeric_sensor_pdr>
     return parsedPdr;
 }
 
+void Terminus::addCompactNumericSensor(
+    const std::shared_ptr<pldm_compact_numeric_sensor_pdr> pdr)
+{
+    uint16_t sensorId = pdr->sensor_id;
+    std::string sensorName = "PLDM_Device_" + std::to_string(sensorId) + "_" +
+                             std::to_string(tid);
+
+    auto sensorAuxiliaryNames = getSensorAuxiliaryNames(sensorId);
+    if (sensorAuxiliaryNames)
+    {
+        const auto& [sensorId, sensorCnt, sensorNames] = *sensorAuxiliaryNames;
+        if (sensorCnt == 1)
+        {
+            for (const auto& [languageTag, name] : sensorNames[0])
+            {
+                if (languageTag == "en")
+                {
+                    {
+                        sensorName = name + "_" + std::to_string(sensorId) +
+                                     "_" + std::to_string(tid);
+                    }
+                }
+            }
+        }
+    }
+
+    try
+    {
+        auto sensor = std::make_shared<NumericSensor>(
+            tid, true, pdr, sensorName, inventoryPath);
+        lg2::info("Created Compact NumericSensor {NAME}", "NAME", sensorName);
+        numericSensors.emplace_back(sensor);
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        lg2::error(
+            "Failed to create Compact NumericSensor. error - {ERROR} sensorname - {NAME}",
+            "ERROR", e, "NAME", sensorName);
+    }
+}
+
 } // namespace platform_mc
 } // namespace pldm
diff --git a/platform-mc/terminus.hpp b/platform-mc/terminus.hpp
index 8fa4ea0..9105b05 100644
--- a/platform-mc/terminus.hpp
+++ b/platform-mc/terminus.hpp
@@ -3,7 +3,9 @@
 #include "libpldm/platform.h"
 
 #include "common/types.hpp"
+#include "numeric_sensor.hpp"
 #include "requester/handler.hpp"
+#include "terminus.hpp"
 
 #include <sdbusplus/server/object.hpp>
 #include <sdeventplus/event.hpp>
@@ -28,6 +30,8 @@ using SensorName = std::string;
 using SensorAuxiliaryNames = std::tuple<
     SensorId, SensorCnt,
     std::vector<std::vector<std::pair<NameLanguageTag, SensorName>>>>;
+using InventoryItemBoardIntf = sdbusplus::server::object_t<
+    sdbusplus::xyz::openbmc_project::Inventory::Item::server::Board>;
 
 /**
  * @brief Terminus
@@ -98,6 +102,9 @@ class Terminus
     /** @brief A flag to indicate if terminus has been initialized */
     bool initialized = false;
 
+    /** @brief A list of numericSensors */
+    std::vector<std::shared_ptr<NumericSensor>> numericSensors{};
+
     /** @brief Get Sensor Auxiliary Names by sensorID
      *
      *  @param[in] id - sensor ID
@@ -106,6 +113,15 @@ class Terminus
     std::shared_ptr<SensorAuxiliaryNames> getSensorAuxiliaryNames(SensorId id);
 
   private:
+    /** @brief Construct the NumericSensor sensor class for the PLDM sensor.
+     *         The NumericSensor class will handle create D-Bus object path,
+     *         provide the APIs to update sensor value, threshold...
+     *
+     *  @param[in] pdr - the numeric sensor PDR info
+     */
+    void addNumericSensor(
+        const std::shared_ptr<pldm_numeric_sensor_value_pdr> pdr);
+
     /** @brief Parse the numeric sensor PDRs
      *
      *  @param[in] pdrData - the response PDRs from GetPDR command
@@ -122,6 +138,14 @@ class Terminus
     std::shared_ptr<SensorAuxiliaryNames>
         parseSensorAuxiliaryNamesPDR(const std::vector<uint8_t>& pdrData);
 
+    /** @brief Construct the NumericSensor sensor class for the compact numeric
+     *         PLDM sensor.
+     *
+     *  @param[in] pdr - the compact numeric sensor PDR info
+     */
+    void addCompactNumericSensor(
+        const std::shared_ptr<pldm_compact_numeric_sensor_pdr> pdr);
+
     /** @brief Parse the compact numeric sensor PDRs
      *
      *  @param[in] pdrData - the response PDRs from GetPDR command
@@ -157,6 +181,12 @@ class Terminus
     /* @brief Sensor Auxiliary Name list */
     std::vector<std::shared_ptr<SensorAuxiliaryNames>>
         sensorAuxiliaryNamesTbl{};
+
+    /* @brief The pointer of iventory D-Bus interface for the terminus */
+    std::unique_ptr<InventoryItemBoardIntf> inventoryItemBoardInft = nullptr;
+
+    /* @brief Inventory D-Bus object path of the terminus */
+    std::string inventoryPath;
 };
 } // namespace platform_mc
 } // namespace pldm
diff --git a/platform-mc/terminus_manager.cpp b/platform-mc/terminus_manager.cpp
index 54d749d..e9b6781 100644
--- a/platform-mc/terminus_manager.cpp
+++ b/platform-mc/terminus_manager.cpp
@@ -160,6 +160,7 @@ auto TerminusManager::findTeminusPtr(const MctpInfo& mctpInfo)
 
 exec::task<int> TerminusManager::discoverMctpTerminusTask()
 {
+    std::vector<pldm_tid_t> addedTids;
     while (!queuedMctpInfos.empty())
     {
         if (manager)
@@ -175,11 +176,23 @@ exec::task<int> TerminusManager::discoverMctpTerminusTask()
             {
                 co_await initMctpTerminus(mctpInfo);
             }
+
+            /* Get TID of initialized terminus */
+            auto tid = toTid(mctpInfo);
+            if (!tid)
+            {
+                co_return PLDM_ERROR;
+            }
+            addedTids.push_back(tid.value());
         }
 
         if (manager)
         {
             co_await manager->afterDiscoverTerminus();
+            for (auto& tid : addedTids)
+            {
+                manager->startSensorPolling(tid);
+            }
         }
 
         queuedMctpInfos.pop();
@@ -199,6 +212,11 @@ void TerminusManager::removeMctpTerminus(const MctpInfos& mctpInfos)
             continue;
         }
 
+        if (manager)
+        {
+            manager->stopSensorPolling(it->second->getTid());
+        }
+
         unmapTid(it->first);
         termini.erase(it);
     }
diff --git a/platform-mc/test/meson.build b/platform-mc/test/meson.build
index 8c4f570..64177cc 100644
--- a/platform-mc/test/meson.build
+++ b/platform-mc/test/meson.build
@@ -4,6 +4,8 @@ test_src = declare_dependency(
             '../terminus.cpp',
             '../platform_manager.cpp',
             '../manager.cpp',
+            '../sensor_manager.cpp',
+            '../numeric_sensor.cpp',
             '../../requester/mctp_endpoint_discovery.cpp'],
             include_directories: ['../../requester', '../../pldmd'])
 
@@ -11,6 +13,8 @@ tests = [
   'terminus_manager_test',
   'terminus_test',
   'platform_manager_test',
+  'sensor_manager_test',
+  'numeric_sensor_test',
 ]
 
 foreach t : tests
diff --git a/platform-mc/test/mock_sensor_manager.hpp b/platform-mc/test/mock_sensor_manager.hpp
new file mode 100644
index 0000000..2c2ea1b
--- /dev/null
+++ b/platform-mc/test/mock_sensor_manager.hpp
@@ -0,0 +1,24 @@
+#pragma once
+
+#include "platform-mc/sensor_manager.hpp"
+
+#include <gmock/gmock.h>
+
+namespace pldm
+{
+namespace platform_mc
+{
+
+class MockSensorManager : public SensorManager
+{
+  public:
+    MockSensorManager(sdeventplus::Event& event,
+                      TerminusManager& terminusManager,
+                      TerminiMapper& termini) :
+        SensorManager(event, terminusManager, termini){};
+
+    MOCK_METHOD(void, doSensorPolling, (pldm_tid_t tid), (override));
+};
+
+} // namespace platform_mc
+} // namespace pldm
diff --git a/platform-mc/test/numeric_sensor_test.cpp b/platform-mc/test/numeric_sensor_test.cpp
new file mode 100644
index 0000000..8b59401
--- /dev/null
+++ b/platform-mc/test/numeric_sensor_test.cpp
@@ -0,0 +1,272 @@
+
+#include "libpldm/entity.h"
+#include "libpldm/platform.h"
+
+#include "platform-mc/numeric_sensor.hpp"
+#include "platform-mc/terminus.hpp"
+
+#include <gtest/gtest.h>
+
+TEST(NumericSensor, conversionFormula)
+{
+    std::vector<uint8_t> pdr1{
+        0x1,
+        0x0,
+        0x0,
+        0x0,                     // record handle
+        0x1,                     // PDRHeaderVersion
+        PLDM_NUMERIC_SENSOR_PDR, // PDRType
+        0x0,
+        0x0,                     // recordChangeNumber
+        PLDM_PDR_NUMERIC_SENSOR_PDR_FIXED_LENGTH +
+            PLDM_PDR_NUMERIC_SENSOR_PDR_VARIED_SENSOR_DATA_SIZE_MIN_LENGTH +
+            PLDM_PDR_NUMERIC_SENSOR_PDR_VARIED_RANGE_FIELD_MIN_LENGTH,
+        0,                             // dataLength
+        0,
+        0,                             // PLDMTerminusHandle
+        0x1,
+        0x0,                           // sensorID=1
+        PLDM_ENTITY_POWER_SUPPLY,
+        0,                             // entityType=Power Supply(120)
+        1,
+        0,                             // entityInstanceNumber
+        0x1,
+        0x0,                           // containerID=1
+        PLDM_NO_INIT,                  // sensorInit
+        false,                         // sensorAuxiliaryNamesPDR
+        PLDM_SENSOR_UNIT_DEGRESS_C,    // baseUint(2)=degrees C
+        1,                             // unitModifier = 1
+        0,                             // rateUnit
+        0,                             // baseOEMUnitHandle
+        0,                             // auxUnit
+        0,                             // auxUnitModifier
+        0,                             // auxRateUnit
+        0,                             // rel
+        0,                             // auxOEMUnitHandle
+        true,                          // isLinear
+        PLDM_RANGE_FIELD_FORMAT_SINT8, // sensorDataSize
+        0,
+        0,
+        0xc0,
+        0x3f, // resolution=1.5
+        0,
+        0,
+        0x80,
+        0x3f, // offset=1.0
+        0,
+        0,    // accuracy
+        0,    // plusTolerance
+        0,    // minusTolerance
+        2,    // hysteresis
+        0,    // supportedThresholds
+        0,    // thresholdAndHysteresisVolatility
+        0,
+        0,
+        0x80,
+        0x3f, // stateTransistionInterval=1.0
+        0,
+        0,
+        0x80,
+        0x3f,                          // updateInverval=1.0
+        255,                           // maxReadable
+        0,                             // minReadable
+        PLDM_RANGE_FIELD_FORMAT_UINT8, // rangeFieldFormat
+        0,                             // rangeFieldsupport
+        0,                             // nominalValue
+        0,                             // normalMax
+        0,                             // normalMin
+        0,                             // warningHigh
+        0,                             // warningLow
+        0,                             // criticalHigh
+        0,                             // criticalLow
+        0,                             // fatalHigh
+        0                              // fatalLow
+    };
+
+    auto numericSensorPdr = std::make_shared<pldm_numeric_sensor_value_pdr>();
+    std::printf("pdr size=%ld\n", pdr1.size());
+    auto rc = decode_numeric_sensor_pdr_data(pdr1.data(), pdr1.size(),
+                                             numericSensorPdr.get());
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    std::string sensorName{"test1"};
+    std::string inventoryPath{
+        "/xyz/openbmc_project/inventroy/Item/Board/PLDM_device_1"};
+    pldm::platform_mc::NumericSensor sensor(0x01, true, numericSensorPdr,
+                                            sensorName, inventoryPath);
+    double reading = 40.0;
+    double convertedValue = 0;
+    convertedValue = sensor.conversionFormula(reading);
+    convertedValue = sensor.unitModifier(convertedValue);
+
+    // (40*1.5 + 1.0 ) * 10^1 = 610
+    EXPECT_EQ(610, convertedValue);
+}
+
+TEST(NumericSensor, checkThreshold)
+{
+    std::vector<uint8_t> pdr1{
+        0x1,
+        0x0,
+        0x0,
+        0x0,                     // record handle
+        0x1,                     // PDRHeaderVersion
+        PLDM_NUMERIC_SENSOR_PDR, // PDRType
+        0x0,
+        0x0,                     // recordChangeNumber
+        PLDM_PDR_NUMERIC_SENSOR_PDR_FIXED_LENGTH +
+            PLDM_PDR_NUMERIC_SENSOR_PDR_VARIED_SENSOR_DATA_SIZE_MIN_LENGTH +
+            PLDM_PDR_NUMERIC_SENSOR_PDR_VARIED_RANGE_FIELD_MIN_LENGTH,
+        0,                             // dataLength
+        0,
+        0,                             // PLDMTerminusHandle
+        0x1,
+        0x0,                           // sensorID=1
+        PLDM_ENTITY_POWER_SUPPLY,
+        0,                             // entityType=Power Supply(120)
+        1,
+        0,                             // entityInstanceNumber
+        0x1,
+        0x0,                           // containerID=1
+        PLDM_NO_INIT,                  // sensorInit
+        false,                         // sensorAuxiliaryNamesPDR
+        PLDM_SENSOR_UNIT_DEGRESS_C,    // baseUint(2)=degrees C
+        1,                             // unitModifier = 1
+        0,                             // rateUnit
+        0,                             // baseOEMUnitHandle
+        0,                             // auxUnit
+        0,                             // auxUnitModifier
+        0,                             // auxRateUnit
+        0,                             // rel
+        0,                             // auxOEMUnitHandle
+        true,                          // isLinear
+        PLDM_RANGE_FIELD_FORMAT_SINT8, // sensorDataSize
+        0,
+        0,
+        0xc0,
+        0x3f, // resolution=1.5
+        0,
+        0,
+        0x80,
+        0x3f, // offset=1.0
+        0,
+        0,    // accuracy
+        0,    // plusTolerance
+        0,    // minusTolerance
+        2,    // hysteresis
+        0,    // supportedThresholds
+        0,    // thresholdAndHysteresisVolatility
+        0,
+        0,
+        0x80,
+        0x3f, // stateTransistionInterval=1.0
+        0,
+        0,
+        0x80,
+        0x3f,                          // updateInverval=1.0
+        255,                           // maxReadable
+        0,                             // minReadable
+        PLDM_RANGE_FIELD_FORMAT_UINT8, // rangeFieldFormat
+        0,                             // rangeFieldsupport
+        0,                             // nominalValue
+        0,                             // normalMax
+        0,                             // normalMin
+        0,                             // warningHigh
+        0,                             // warningLow
+        0,                             // criticalHigh
+        0,                             // criticalLow
+        0,                             // fatalHigh
+        0                              // fatalLow
+    };
+
+    auto numericSensorPdr = std::make_shared<pldm_numeric_sensor_value_pdr>();
+    auto rc = decode_numeric_sensor_pdr_data(pdr1.data(), pdr1.size(),
+                                             numericSensorPdr.get());
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+    std::string sensorName{"test1"};
+    std::string inventoryPath{
+        "/xyz/openbmc_project/inventroy/Item/Board/PLDM_device_1"};
+    pldm::platform_mc::NumericSensor sensor(0x01, true, numericSensorPdr,
+                                            sensorName, inventoryPath);
+
+    bool highAlarm = false;
+    bool lowAlarm = false;
+    double highThreshold = 40;
+    double lowThreshold = 30;
+    double hysteresis = 2;
+
+    // reading     35->40->45->38->35->30->25->32->35
+    // highAlarm    F->T ->T ->T ->F ->F ->F -> F-> F
+    // lowAlarm     F->F ->F ->F ->F ->T ->T -> T ->F
+    double reading = 35;
+    highAlarm = sensor.checkThreshold(highAlarm, true, reading, highThreshold,
+                                      hysteresis);
+    EXPECT_EQ(false, highAlarm);
+    lowAlarm = sensor.checkThreshold(lowAlarm, false, reading, lowThreshold,
+                                     hysteresis);
+    EXPECT_EQ(false, lowAlarm);
+
+    reading = 40;
+    highAlarm = sensor.checkThreshold(highAlarm, true, reading, highThreshold,
+                                      hysteresis);
+    EXPECT_EQ(true, highAlarm);
+    lowAlarm = sensor.checkThreshold(lowAlarm, false, reading, lowThreshold,
+                                     hysteresis);
+    EXPECT_EQ(false, lowAlarm);
+
+    reading = 45;
+    highAlarm = sensor.checkThreshold(highAlarm, true, reading, highThreshold,
+                                      hysteresis);
+    EXPECT_EQ(true, highAlarm);
+    lowAlarm = sensor.checkThreshold(lowAlarm, false, reading, lowThreshold,
+                                     hysteresis);
+    EXPECT_EQ(false, lowAlarm);
+
+    reading = 38;
+    highAlarm = sensor.checkThreshold(highAlarm, true, reading, highThreshold,
+                                      hysteresis);
+    EXPECT_EQ(true, highAlarm);
+    lowAlarm = sensor.checkThreshold(lowAlarm, false, reading, lowThreshold,
+                                     hysteresis);
+    EXPECT_EQ(false, lowAlarm);
+
+    reading = 35;
+    highAlarm = sensor.checkThreshold(highAlarm, true, reading, highThreshold,
+                                      hysteresis);
+    EXPECT_EQ(false, highAlarm);
+    lowAlarm = sensor.checkThreshold(lowAlarm, false, reading, lowThreshold,
+                                     hysteresis);
+    EXPECT_EQ(false, lowAlarm);
+
+    reading = 30;
+    highAlarm = sensor.checkThreshold(highAlarm, true, reading, highThreshold,
+                                      hysteresis);
+    EXPECT_EQ(false, highAlarm);
+    lowAlarm = sensor.checkThreshold(lowAlarm, false, reading, lowThreshold,
+                                     hysteresis);
+    EXPECT_EQ(true, lowAlarm);
+
+    reading = 25;
+    highAlarm = sensor.checkThreshold(highAlarm, true, reading, highThreshold,
+                                      hysteresis);
+    EXPECT_EQ(false, highAlarm);
+    lowAlarm = sensor.checkThreshold(lowAlarm, false, reading, lowThreshold,
+                                     hysteresis);
+    EXPECT_EQ(true, lowAlarm);
+
+    reading = 32;
+    highAlarm = sensor.checkThreshold(highAlarm, true, reading, highThreshold,
+                                      hysteresis);
+    EXPECT_EQ(false, highAlarm);
+    lowAlarm = sensor.checkThreshold(lowAlarm, false, reading, lowThreshold,
+                                     hysteresis);
+    EXPECT_EQ(true, lowAlarm);
+
+    reading = 35;
+    highAlarm = sensor.checkThreshold(highAlarm, true, reading, highThreshold,
+                                      hysteresis);
+    EXPECT_EQ(false, highAlarm);
+    lowAlarm = sensor.checkThreshold(lowAlarm, false, reading, lowThreshold,
+                                     hysteresis);
+    EXPECT_EQ(false, lowAlarm);
+}
diff --git a/platform-mc/test/platform_manager_test.cpp b/platform-mc/test/platform_manager_test.cpp
index 2df2b48..5fa7780 100644
--- a/platform-mc/test/platform_manager_test.cpp
+++ b/platform-mc/test/platform_manager_test.cpp
@@ -150,6 +150,7 @@ TEST_F(PlatformManagerTest, initTerminusTest)
     stdexec::sync_wait(platformManager.initTerminus());
     EXPECT_EQ(true, terminus->initialized);
     EXPECT_EQ(1, terminus->pdrs.size());
+    EXPECT_EQ(1, terminus->numericSensors.size());
 }
 
 TEST_F(PlatformManagerTest, initTerminusDontSupportGetPDRTest)
@@ -282,6 +283,7 @@ TEST_F(PlatformManagerTest, negativeInitTerminusTest1)
     stdexec::sync_wait(platformManager.initTerminus());
     EXPECT_EQ(true, terminus->initialized);
     EXPECT_EQ(0, terminus->pdrs.size());
+    EXPECT_EQ(0, terminus->numericSensors.size());
 }
 
 TEST_F(PlatformManagerTest, negativeInitTerminusTest2)
@@ -313,4 +315,5 @@ TEST_F(PlatformManagerTest, negativeInitTerminusTest2)
     stdexec::sync_wait(platformManager.initTerminus());
     EXPECT_EQ(true, terminus->initialized);
     EXPECT_EQ(0, terminus->pdrs.size());
+    EXPECT_EQ(0, terminus->numericSensors.size());
 }
diff --git a/platform-mc/test/sensor_manager_test.cpp b/platform-mc/test/sensor_manager_test.cpp
new file mode 100644
index 0000000..cd4e5a4
--- /dev/null
+++ b/platform-mc/test/sensor_manager_test.cpp
@@ -0,0 +1,147 @@
+#include "common/instance_id.hpp"
+#include "common/types.hpp"
+#include "mock_sensor_manager.hpp"
+#include "platform-mc/terminus_manager.hpp"
+#include "test/test_instance_id.hpp"
+
+#include <sdeventplus/event.hpp>
+
+#include <gtest/gtest.h>
+
+using ::testing::_;
+using ::testing::Between;
+using ::testing::Return;
+
+class SensorManagerTest : public testing::Test
+{
+  protected:
+    SensorManagerTest() :
+        bus(pldm::utils::DBusHandler::getBus()),
+        event(sdeventplus::Event::get_default()), instanceIdDb(),
+        reqHandler(pldmTransport, event, instanceIdDb, false),
+        terminusManager(event, reqHandler, instanceIdDb, termini, nullptr),
+        sensorManager(event, terminusManager, termini)
+    {}
+
+    void runEventLoopForSeconds(uint64_t sec)
+    {
+        uint64_t t0 = 0;
+        uint64_t t1 = 0;
+        uint64_t usec = sec * 1000000;
+        uint64_t elapsed = 0;
+        sd_event_now(event.get(), CLOCK_MONOTONIC, &t0);
+        do
+        {
+            if (!sd_event_run(event.get(), usec - elapsed))
+            {
+                break;
+            }
+            sd_event_now(event.get(), CLOCK_MONOTONIC, &t1);
+            elapsed = t1 - t0;
+        } while (elapsed < usec);
+    }
+
+    PldmTransport* pldmTransport = nullptr;
+    sdbusplus::bus::bus& bus;
+    sdeventplus::Event event;
+    TestInstanceIdDb instanceIdDb;
+    pldm::requester::Handler<pldm::requester::Request> reqHandler;
+    pldm::platform_mc::TerminusManager terminusManager;
+    pldm::platform_mc::MockSensorManager sensorManager;
+    std::map<pldm_tid_t, std::shared_ptr<pldm::platform_mc::Terminus>> termini;
+
+    std::vector<uint8_t> pdr1{
+        0x1,
+        0x0,
+        0x0,
+        0x0,                     // record handle
+        0x1,                     // PDRHeaderVersion
+        PLDM_NUMERIC_SENSOR_PDR, // PDRType
+        0x0,
+        0x0,                     // recordChangeNumber
+        PLDM_PDR_NUMERIC_SENSOR_PDR_FIXED_LENGTH +
+            PLDM_PDR_NUMERIC_SENSOR_PDR_VARIED_SENSOR_DATA_SIZE_MIN_LENGTH +
+            PLDM_PDR_NUMERIC_SENSOR_PDR_VARIED_RANGE_FIELD_MIN_LENGTH,
+        0,                             // dataLength
+        0,
+        0,                             // PLDMTerminusHandle
+        0x1,
+        0x0,                           // sensorID=1
+        PLDM_ENTITY_POWER_SUPPLY,
+        0,                             // entityType=Power Supply(120)
+        1,
+        0,                             // entityInstanceNumber
+        0x1,
+        0x0,                           // containerID=1
+        PLDM_NO_INIT,                  // sensorInit
+        false,                         // sensorAuxiliaryNamesPDR
+        PLDM_SENSOR_UNIT_DEGRESS_C,    // baseUint(2)=degrees C
+        1,                             // unitModifier = 1
+        0,                             // rateUnit
+        0,                             // baseOEMUnitHandle
+        0,                             // auxUnit
+        0,                             // auxUnitModifier
+        0,                             // auxRateUnit
+        0,                             // rel
+        0,                             // auxOEMUnitHandle
+        true,                          // isLinear
+        PLDM_RANGE_FIELD_FORMAT_SINT8, // sensorDataSize
+        0,
+        0,
+        0xc0,
+        0x3f, // resolution=1.5
+        0,
+        0,
+        0x80,
+        0x3f, // offset=1.0
+        0,
+        0,    // accuracy
+        0,    // plusTolerance
+        0,    // minusTolerance
+        2,    // hysteresis
+        0,    // supportedThresholds
+        0,    // thresholdAndHysteresisVolatility
+        0,
+        0,
+        0x80,
+        0x3f, // stateTransistionInterval=1.0
+        0,
+        0,
+        0x80,
+        0x3f,                          // updateInverval=1.0
+        255,                           // maxReadable
+        0,                             // minReadable
+        PLDM_RANGE_FIELD_FORMAT_UINT8, // rangeFieldFormat
+        0,                             // rangeFieldsupport
+        0,                             // nominalValue
+        0,                             // normalMax
+        0,                             // normalMin
+        0,                             // warningHigh
+        0,                             // warningLow
+        0,                             // criticalHigh
+        0,                             // criticalLow
+        0,                             // fatalHigh
+        0                              // fatalLow
+    };
+};
+
+TEST_F(SensorManagerTest, sensorPollingTest)
+{
+    uint64_t seconds = 10;
+    uint64_t expectedTimes = (seconds * 1000) / SENSOR_POLLING_TIME;
+
+    pldm_tid_t tid = 1;
+    termini[tid] = std::make_shared<pldm::platform_mc::Terminus>(tid, 0);
+    termini[tid]->pdrs.push_back(pdr1);
+    termini[tid]->parsePDRs();
+
+    EXPECT_CALL(sensorManager, doSensorPolling(tid))
+        .Times(Between(expectedTimes - 3, expectedTimes + 3))
+        .WillRepeatedly(Return());
+
+    sensorManager.startPolling(tid);
+
+    runEventLoopForSeconds(seconds);
+
+    sensorManager.stopPolling(tid);
+}
diff --git a/pldmd/pldmd.cpp b/pldmd/pldmd.cpp
index 4df71e9..768c6c9 100644
--- a/pldmd/pldmd.cpp
+++ b/pldmd/pldmd.cpp
@@ -187,7 +187,7 @@ int main(int argc, char** argv)
     auto event = Event::get_default();
     auto& bus = pldm::utils::DBusHandler::getBus();
     sdbusplus::server::manager_t objManager(bus,
-                                            "/xyz/openbmc_project/software");
+                                            "/xyz/openbmc_project/sensors");
 
     InstanceIdDb instanceIdDb;
     dbus_api::Requester dbusImplReq(bus, "/xyz/openbmc_project/pldm",
-- 
2.43.0

