From 1e3f077c7870bf8cb2d089334451a4f7abda9907 Mon Sep 17 00:00:00 2001
From: Gilbert Chen <gilbertc@nvidia.com>
Date: Tue, 2 May 2023 10:20:10 +0000
Subject: [PATCH 06/11] platform-mc: Added EventManager

Added eventManager to handle sensor event class(00h),
pldmMessagePollEvent class(05h)  and OEM CPER event class(FAh)
which are defined in table 11 of DSP0248 v1.2.1. The eventManager
supports to receive event asynchronously and polls all event
synchronously if terminus sends pldmMessagePollEvent.

Change-Id: I1b337ccae454067841ffbbd8754631216a995542
Signed-off-by: Thu Nguyen <thu@os.amperecomputing.com>
Signed-off-by: Gilbert Chen <gilbertc@nvidia.com>

%% original patch: 0006-platform-mc-Added-EventManager.patch
---
 libpldmresponder/platform.cpp              |   9 +-
 meson.build                                |   2 +
 meson.options                              |   9 +
 platform-mc/event_manager.cpp              | 660 +++++++++++++++++++++
 platform-mc/event_manager.hpp              | 130 ++++
 platform-mc/manager.hpp                    |  56 +-
 platform-mc/platform_manager.cpp           | 182 +++++-
 platform-mc/platform_manager.hpp           |  46 +-
 platform-mc/sensor_manager.cpp             |  14 +-
 platform-mc/sensor_manager.hpp             |   5 +-
 platform-mc/terminus.cpp                   |   6 +-
 platform-mc/terminus.hpp                   |  12 +
 platform-mc/terminus_manager.hpp           |  17 +-
 platform-mc/test/event_manager_test.cpp    | 418 +++++++++++++
 platform-mc/test/meson.build               |   2 +
 platform-mc/test/mock_event_manager.hpp    |  29 +
 platform-mc/test/mock_sensor_manager.hpp   |   5 +-
 platform-mc/test/mock_terminus_manager.hpp |   3 +-
 platform-mc/test/platform_manager_test.cpp |  21 +-
 platform-mc/test/sensor_manager_test.cpp   |   4 +-
 platform-mc/test/terminus_manager_test.cpp |   2 +-
 pldmd/pldmd.cpp                            |  31 +-
 22 files changed, 1640 insertions(+), 23 deletions(-)
 create mode 100644 platform-mc/event_manager.cpp
 create mode 100644 platform-mc/event_manager.hpp
 create mode 100644 platform-mc/test/event_manager_test.cpp
 create mode 100644 platform-mc/test/mock_event_manager.hpp

diff --git a/libpldmresponder/platform.cpp b/libpldmresponder/platform.cpp
index 0e5455c..fce004a 100644
--- a/libpldmresponder/platform.cpp
+++ b/libpldmresponder/platform.cpp
@@ -368,15 +368,20 @@ Response Handler::platformEventMessage(const pldm_msg* request,
         try
         {
             const auto& handlers = eventHandlers.at(eventClass);
+            bool handled = false;
             for (const auto& handler : handlers)
             {
                 auto rc = handler(request, payloadLength, formatVersion, tid,
                                   offset);
-                if (rc != PLDM_SUCCESS)
+                if (rc == PLDM_SUCCESS)
                 {
-                    return CmdHandler::ccOnlyResponse(request, rc);
+                    handled = true;
                 }
             }
+            if (handled == false)
+            {
+                return CmdHandler::ccOnlyResponse(request, rc);
+            }
         }
         catch (const std::out_of_range& e)
         {
diff --git a/meson.build b/meson.build
index d51c5f7..0221ad3 100644
--- a/meson.build
+++ b/meson.build
@@ -72,6 +72,7 @@ endif
 conf_data.set_quoted('STATIC_EID_TABLE_PATH', join_paths(package_datadir, 'static_eid_table.json'))
 conf_data.set('SENSOR_POLLING_TIME', get_option('sensor-polling-time'))
 conf_data.set_quoted('PLDM_T2_CONFIG_JSON', join_paths(package_datadir, 'pldm_t2_config.json'))
+conf_data.set('LOCAL_EID', get_option('local-eid'))
 config = configure_file(output: 'config.h',
   configuration: conf_data
 )
@@ -187,6 +188,7 @@ executable(
   'platform-mc/platform_manager.cpp',
   'platform-mc/sensor_manager.cpp',
   'platform-mc/numeric_sensor.cpp',
+  'platform-mc/event_manager.cpp',
   'requester/mctp_endpoint_discovery.cpp',
   implicit_include_directories: false,
   dependencies: deps,
diff --git a/meson.options b/meson.options
index 3f24007..b5e1064 100644
--- a/meson.options
+++ b/meson.options
@@ -185,3 +185,12 @@ option(
     description: 'The interval time of sensor polling in milliseconds',
     value: 249
 )
+
+## BMC endpoint Options
+option(
+    'local-eid',
+    type: 'integer',
+    min: 1,
+    max: 255,
+    description: 'The local MCTP EID',
+    value: 8)
diff --git a/platform-mc/event_manager.cpp b/platform-mc/event_manager.cpp
new file mode 100644
index 0000000..dcc39ca
--- /dev/null
+++ b/platform-mc/event_manager.cpp
@@ -0,0 +1,660 @@
+#include "event_manager.hpp"
+
+#include "libpldm/utils.h"
+
+#include "terminus_manager.hpp"
+
+#include <phosphor-logging/lg2.hpp>
+#include <xyz/openbmc_project/Logging/Entry/server.hpp>
+
+#include <cerrno>
+
+namespace pldm
+{
+namespace platform_mc
+{
+namespace fs = std::filesystem;
+
+/** @brief PLDM cperEventClass formatType
+ */
+enum cper_event_class_format_type
+{
+    PLDM_FORMAT_TYPE_CPER = 0x0,
+    PLDM_FORMAT_TYPE_CPER_SECTION = 0x1
+};
+
+/* Minumum length of pldm cper event data */
+#define PLDM_CPER_EVENT_DATA_MIN_LENGTH 4
+
+/** @struct pldm_cper_event
+ *
+ *  structure representing CPEREvent
+ */
+struct pldm_cper_event_data
+{
+    uint8_t format_version;
+    uint8_t format_type;
+    uint16_t event_data_length;
+    uint8_t event_data[1];
+} __attribute__((packed));
+
+/** @brief Decode cperEvent response data
+ *
+ *  @param[in] event_data - event data from the response message
+ *  @param[in] event_data_length - length of the event data
+ *  @param[out] format_version - version of the event format
+ *  @param[out] format_type - 0x00=CPER(full record), 0x01=CPER Section(signal
+ * CPER section)
+ *  @param[out] cper_event_data_length - length in bytes of cper_event_data
+ *  @param[out] cper_event_data - the pointer to where cper data is in
+ * event_data array
+ *  @return pldm_completion_codes
+ *  @note  Caller is responsible for memory alloc and dealloc of param
+ *         'event_data'
+ */
+int decode_pldm_cper_event_data(const uint8_t* event_data,
+                                size_t event_data_length,
+                                uint8_t* format_version, uint8_t* format_type,
+                                uint16_t* cper_event_data_length,
+                                uint8_t** cper_event_data)
+{
+    if (event_data == NULL || format_version == NULL || format_type == NULL ||
+        cper_event_data_length == NULL || cper_event_data == NULL)
+    {
+        return PLDM_ERROR_INVALID_DATA;
+    }
+
+    if (event_data_length < PLDM_CPER_EVENT_DATA_MIN_LENGTH)
+    {
+        return PLDM_ERROR_INVALID_LENGTH;
+    }
+
+    struct pldm_cper_event_data* pldm_cper_event =
+        (struct pldm_cper_event_data*)event_data;
+    *format_version = pldm_cper_event->format_version;
+    *format_type = pldm_cper_event->format_type;
+    *cper_event_data_length = le16toh(pldm_cper_event->event_data_length);
+    *cper_event_data = pldm_cper_event->event_data;
+
+    return PLDM_SUCCESS;
+}
+
+int EventManager::handlePlatformEvent(tid_t tid, uint8_t eventClass,
+                                      const uint8_t* eventData,
+                                      size_t eventDataSize)
+{
+    if (eventClass == PLDM_SENSOR_EVENT)
+    {
+        uint16_t sensorId = 0;
+        uint8_t sensorEventClassType = 0;
+        size_t eventClassDataOffset = 0;
+        auto rc = decode_sensor_event_data(eventData, eventDataSize, &sensorId,
+                                           &sensorEventClassType,
+                                           &eventClassDataOffset);
+        if (rc)
+        {
+            lg2::error("Failed to decode sensor event data, rc={RC}.", "RC",
+                       rc);
+            return rc;
+        }
+        switch (sensorEventClassType)
+        {
+            case PLDM_NUMERIC_SENSOR_STATE:
+            {
+                const uint8_t* sensorData = eventData + eventClassDataOffset;
+                size_t sensorDataLength = eventDataSize - eventClassDataOffset;
+                return processNumericSensorEvent(tid, sensorId, sensorData,
+                                                 sensorDataLength);
+            }
+            case PLDM_STATE_SENSOR_STATE:
+            case PLDM_SENSOR_OP_STATE:
+            default:
+                lg2::info("unhandled sensor event, class type={CLASSTYPE}",
+                          "CLASSTYPE", sensorEventClassType);
+                return PLDM_ERROR;
+        }
+    }
+    else if (eventClass == PLDM_MESSAGE_POLL_EVENT)
+    {
+        lg2::info("received poll event tid={TID}", "TID", tid);
+        auto it = termini.find(tid);
+        if (it != termini.end())
+        {
+            termini[tid]->pollEvent = true;
+        }
+        return PLDM_SUCCESS;
+    }
+    else if (eventClass == PLDM_OEM_EVENT_CLASS_0xFA)
+    {
+        return processCperEvent(eventData, eventDataSize);
+    }
+
+    lg2::info("unhandled event, event class={EVENTCLASS}", "EVENTCLASS",
+              eventClass);
+
+    return PLDM_ERROR;
+}
+
+requester::Coroutine EventManager::pollForPlatformEventTask(tid_t tid)
+{
+    uint8_t rc = 0;
+    uint8_t transferOperationFlag = PLDM_GET_FIRSTPART;
+    uint32_t dataTransferHandle = 0;
+    uint32_t eventIdToAcknowledge = 0;
+
+    uint8_t completionCode;
+    uint8_t eventTid;
+    uint16_t eventId = 0xffff;
+    uint32_t nextDataTransferHandle;
+    uint8_t transferFlag;
+    uint8_t eventClass;
+    uint32_t eventDataSize;
+    uint8_t* eventData;
+    uint32_t eventDataIntegrityChecksum;
+
+    std::vector<uint8_t> eventMessage{};
+
+    while (eventId != 0)
+    {
+        completionCode = 0;
+        eventTid = 0;
+        eventId = 0;
+        nextDataTransferHandle = 0;
+        transferFlag = 0;
+        eventClass = 0;
+        eventDataSize = 0;
+        eventData = nullptr;
+        eventDataIntegrityChecksum = 0;
+
+        rc = co_await pollForPlatformEventMessage(
+            tid, transferOperationFlag, dataTransferHandle,
+            eventIdToAcknowledge, completionCode, eventTid, eventId,
+            nextDataTransferHandle, transferFlag, eventClass, eventDataSize,
+            eventData, eventDataIntegrityChecksum);
+        if (rc || completionCode != PLDM_SUCCESS)
+        {
+            lg2::error(
+                "pollForPlatformEventMessage failed. tid={TID} transferOpFlag={OPFLAG} rc={RC} cc={CC}",
+                "TID", tid, "OPFLAG", transferOperationFlag, "RC", rc, "CC",
+                completionCode);
+            co_return rc;
+        }
+
+        if (eventDataSize > 0)
+        {
+            eventMessage.insert(eventMessage.end(), eventData,
+                                eventData + eventDataSize);
+        }
+
+        if (transferOperationFlag == PLDM_ACKNOWLEDGEMENT_ONLY)
+        {
+            if (eventId == 0xffff)
+            {
+                transferOperationFlag = PLDM_GET_FIRSTPART;
+                dataTransferHandle = 0;
+                eventIdToAcknowledge = 0;
+                eventMessage.clear();
+            }
+        }
+        else
+        {
+            if (transferFlag == PLDM_START || transferFlag == PLDM_MIDDLE)
+            {
+                transferOperationFlag = PLDM_GET_NEXTPART;
+                dataTransferHandle = nextDataTransferHandle;
+                eventIdToAcknowledge = 0xffff;
+            }
+            else
+            {
+                if (transferFlag == PLDM_START_AND_END)
+                {
+                    handlePlatformEvent(eventTid, eventClass,
+                                        eventMessage.data(),
+                                        eventMessage.size());
+                }
+                else if (transferFlag == PLDM_END)
+                {
+                    if (eventDataIntegrityChecksum ==
+                        crc32(eventMessage.data(), eventMessage.size()))
+                    {
+                        handlePlatformEvent(eventTid, eventClass,
+                                            eventMessage.data(),
+                                            eventMessage.size());
+                    }
+                    else
+                    {
+                        lg2::error(
+                            "pollForPlatformEventMessage checksum error, tid={TID} eventId={EVENTID} eventClass={EVENTCLASS} ",
+                            "TID", tid, "EVENTID", eventId, "EVENTCLASS",
+                            eventClass);
+                    }
+                }
+
+                transferOperationFlag = PLDM_ACKNOWLEDGEMENT_ONLY;
+                dataTransferHandle = 0;
+                eventIdToAcknowledge = eventId;
+            }
+        }
+    }
+
+    co_return PLDM_SUCCESS;
+}
+
+requester::Coroutine EventManager::pollForPlatformEventMessage(
+    tid_t tid, uint8_t transferOperationFlag, uint32_t dataTransferHandle,
+    uint16_t eventIdToAcknowledge, uint8_t& completionCode, uint8_t& eventTid,
+    uint16_t& eventId, uint32_t& nextDataTransferHandle, uint8_t& transferFlag,
+    uint8_t& eventClass, uint32_t& eventDataSize, uint8_t*& eventData,
+    uint32_t& eventDataIntegrityChecksum)
+{
+    Request request(sizeof(pldm_msg_hdr) +
+                    PLDM_POLL_FOR_PLATFORM_EVENT_MESSAGE_REQ_BYTES);
+    auto requestMsg = reinterpret_cast<pldm_msg*>(request.data());
+    auto rc = encode_poll_for_platform_event_message_req(
+        0, 0x01, transferOperationFlag, dataTransferHandle,
+        eventIdToAcknowledge, requestMsg, request.size());
+    if (rc)
+    {
+        lg2::error(
+            "encode_poll_for_platform_event_message_req tid={TID} rc={RC}",
+            "TID", tid, "RC", rc);
+        co_return rc;
+    }
+
+    const pldm_msg* responseMsg = NULL;
+    size_t responseLen = 0;
+    rc = co_await terminusManager.SendRecvPldmMsg(tid, request, &responseMsg,
+                                                  &responseLen);
+    if (rc)
+    {
+        co_return rc;
+    }
+
+    rc = decode_poll_for_platform_event_message_resp(
+        responseMsg, responseLen, &completionCode, &eventTid, &eventId,
+        &nextDataTransferHandle, &transferFlag, &eventClass, &eventDataSize,
+        (void**)&eventData, &eventDataIntegrityChecksum);
+    if (rc)
+    {
+        lg2::error(
+            "decode_poll_for_platform_event_message_resp tid={TID} rc={RC} responseLen={RLEN}",
+            "TID", tid, "RC", rc, "RLEN", responseLen);
+        co_return rc;
+    }
+    co_return completionCode;
+}
+
+int EventManager::processCperEvent(const uint8_t* eventData,
+                                   size_t eventDataSize)
+{
+    uint8_t formatVersion;
+    uint8_t formatType = 0;
+    uint16_t cperEventDataLength;
+    uint8_t* cperEventData;
+    auto rc = decode_pldm_cper_event_data(eventData, eventDataSize,
+                                          &formatVersion, &formatType,
+                                          &cperEventDataLength, &cperEventData);
+
+    if (rc)
+    {
+        lg2::error("Failed to decode CPER event data, rc={RC}", "RC", rc);
+        return rc;
+    }
+
+    // save event data to file
+    std::string dirName{"/var/cper"};
+    auto dirStatus = fs::status(dirName);
+    if (fs::exists(dirStatus))
+    {
+        if (!fs::is_directory(dirStatus))
+        {
+            lg2::error("Failed to create {DIRNAME} directory", "DIRNAME",
+                       dirName);
+            return PLDM_ERROR;
+        }
+    }
+    else
+    {
+        fs::create_directory(dirName);
+    }
+
+    std::string fileName{dirName + "/cper-XXXXXX"};
+    auto fd = mkstemp(fileName.data());
+    if (fd < 0)
+    {
+        lg2::error("Failed to generate temp file:{ERRORNO}", "ERRORNO",
+                   std::strerror(errno));
+        return PLDM_ERROR;
+    }
+    close(fd);
+
+    std::ofstream ofs;
+    ofs.exceptions(std::ofstream::failbit | std::ofstream::badbit |
+                   std::ofstream::eofbit);
+
+    try
+    {
+        ofs.open(fileName);
+        ofs.write(reinterpret_cast<const char*>(eventData), eventDataSize);
+        if (formatType == PLDM_FORMAT_TYPE_CPER)
+        {
+            rc = createCperDumpEntry("CPER", fileName);
+        }
+        else
+        {
+            rc = createCperDumpEntry("CPERSection", fileName);
+        }
+        ofs.close();
+    }
+    catch (const std::exception& e)
+    {
+        lg2::error("Failed to save CPER to {FILENAME}, {ERROR}.", "FILENAME",
+                   fileName, "ERROR", e);
+        return PLDM_ERROR;
+    }
+    return rc;
+}
+
+int EventManager::createCperDumpEntry(const std::string& dataType,
+                                      const std::string& dataPath)
+{
+    auto createDump = [](std::map<std::string, std::string>& addData) {
+        static constexpr auto dumpObjPath =
+            "/xyz/openbmc_project/dump/faultlog";
+        static constexpr auto dumpInterface = "xyz.openbmc_project.Dump.Create";
+        auto& bus = pldm::utils::DBusHandler::getBus();
+
+        try
+        {
+            auto service = pldm::utils::DBusHandler().getService(dumpObjPath,
+                                                                 dumpInterface);
+            auto method = bus.new_method_call(service.c_str(), dumpObjPath,
+                                              dumpInterface, "CreateDump");
+            method.append(addData);
+            bus.call_noreply(method);
+        }
+        catch (const std::exception& e)
+        {
+            lg2::error("Failed to create D-Bus Dump entry, {ERROR}.", "ERROR",
+                       e);
+        }
+    };
+
+    std::map<std::string, std::string> addData;
+    addData["CPER_TYPE"] = dataType;
+    addData["CPER_PATH"] = dataPath;
+    createDump(addData);
+    return PLDM_SUCCESS;
+}
+
+int EventManager::createSensorThresholdLogEntry(const std::string& messageId,
+                                                const std::string& sensorName,
+                                                const double reading,
+                                                const double threshold)
+{
+    using namespace sdbusplus::xyz::openbmc_project::Logging::server;
+    using Level =
+        sdbusplus::xyz::openbmc_project::Logging::server::Entry::Level;
+
+    auto createLog = [&messageId](std::map<std::string, std::string>& addData,
+                                  Level& level) {
+        static constexpr auto logObjPath = "/xyz/openbmc_project/logging";
+        static constexpr auto logInterface =
+            "xyz.openbmc_project.Logging.Create";
+        auto& bus = pldm::utils::DBusHandler::getBus();
+
+        try
+        {
+            auto service = pldm::utils::DBusHandler().getService(logObjPath,
+                                                                 logInterface);
+            auto severity = sdbusplus::xyz::openbmc_project::Logging::server::
+                convertForMessage(level);
+            auto method = bus.new_method_call(service.c_str(), logObjPath,
+                                              logInterface, "Create");
+            method.append(messageId, severity, addData);
+            bus.call_noreply(method);
+        }
+        catch (const std::exception& e)
+        {
+            lg2::error(
+                "Failed to create D-Bus log entry for message registry, {ERROR}.",
+                "ERROR", e);
+        }
+    };
+
+    std::map<std::string, std::string> addData;
+    addData["REDFISH_MESSAGE_ID"] = messageId;
+    Level level = Level::Informational;
+
+    addData["REDFISH_MESSAGE_ARGS"] = sensorName + "," +
+                                      std::to_string(reading) + "," +
+                                      std::to_string(threshold);
+
+    if (messageId == SensorThresholdWarningLowGoingHigh ||
+        messageId == SensorThresholdWarningHighGoingLow)
+    {
+        level = Level::Informational;
+    }
+    else if (messageId == SensorThresholdWarningLowGoingLow ||
+             messageId == SensorThresholdWarningHighGoingHigh ||
+             messageId == SensorThresholdCriticalLowGoingHigh ||
+             messageId == SensorThresholdCriticalHighGoingLow)
+    {
+        level = Level::Warning;
+    }
+    else if (messageId == SensorThresholdCriticalLowGoingLow ||
+             messageId == SensorThresholdCriticalHighGoingHigh)
+    {
+        level = Level::Critical;
+    }
+    else
+    {
+        lg2::error("Message Registry messageID is not recognised, {MESSAGEID}",
+                   "MESSAGEID", messageId);
+        return PLDM_ERROR;
+    }
+
+    createLog(addData, level);
+    return PLDM_SUCCESS;
+}
+
+int EventManager::processNumericSensorEvent(tid_t tid, uint16_t sensorId,
+                                            const uint8_t* sensorData,
+                                            size_t sensorDataLength)
+{
+    uint8_t eventState = 0;
+    uint8_t previousEventState = 0;
+    uint8_t sensorDataSize = 0;
+    uint32_t presentReading;
+    auto rc = decode_numeric_sensor_data(sensorData, sensorDataLength,
+                                         &eventState, &previousEventState,
+                                         &sensorDataSize, &presentReading);
+    if (rc)
+    {
+        return rc;
+    }
+
+    for (auto& [terminusId, terminus] : termini)
+    {
+        if (tid != terminusId)
+        {
+            continue;
+        }
+        for (auto& sensor : terminus->numericSensors)
+        {
+            if (sensorId != sensor->sensorId)
+            {
+                continue;
+            }
+            std::string messageId =
+                getSensorThresholdMessageId(previousEventState, eventState);
+            double threshold = std::numeric_limits<double>::quiet_NaN();
+            double reading = std::numeric_limits<double>::quiet_NaN();
+            switch (eventState)
+            {
+                case PLDM_SENSOR_LOWERFATAL:
+                case PLDM_SENSOR_LOWERCRITICAL:
+                    threshold = sensor->getThresholdLowerCritical();
+                    break;
+                case PLDM_SENSOR_UPPERFATAL:
+                case PLDM_SENSOR_UPPERCRITICAL:
+                    threshold = sensor->getThresholdUpperCritical();
+                    break;
+                case PLDM_SENSOR_LOWERWARNING:
+                    threshold = sensor->getThresholdLowerWarning();
+                    break;
+                case PLDM_SENSOR_UPPERWARNING:
+                    threshold = sensor->getThresholdUpperWarning();
+                    break;
+                default:
+                    break;
+            }
+            switch (sensorDataSize)
+            {
+                case PLDM_SENSOR_DATA_SIZE_UINT8:
+                    reading = static_cast<double>(
+                        static_cast<uint8_t>(presentReading));
+                    break;
+                case PLDM_SENSOR_DATA_SIZE_SINT8:
+                    reading = static_cast<double>(
+                        static_cast<int8_t>(presentReading));
+                    break;
+                case PLDM_SENSOR_DATA_SIZE_UINT16:
+                    reading = static_cast<double>(
+                        static_cast<uint16_t>(presentReading));
+                    break;
+                case PLDM_SENSOR_DATA_SIZE_SINT16:
+                    reading = static_cast<double>(
+                        static_cast<int16_t>(presentReading));
+                    break;
+                case PLDM_SENSOR_DATA_SIZE_UINT32:
+                    reading = static_cast<double>(
+                        static_cast<uint32_t>(presentReading));
+                    break;
+                case PLDM_SENSOR_DATA_SIZE_SINT32:
+                    reading = static_cast<double>(
+                        static_cast<int32_t>(presentReading));
+                    break;
+                default:
+                    break;
+            }
+            rc = createSensorThresholdLogEntry(
+                messageId, sensor->sensorName,
+                sensor->unitModifier(sensor->conversionFormula(reading)),
+                threshold);
+            return rc;
+        }
+    }
+    return PLDM_ERROR;
+}
+
+std::string
+    EventManager::getSensorThresholdMessageId(uint8_t previousEventState,
+                                              uint8_t eventState)
+{
+    switch (previousEventState)
+    {
+        case PLDM_SENSOR_UPPERFATAL:
+        case PLDM_SENSOR_UPPERCRITICAL:
+            switch (eventState)
+            {
+                case PLDM_SENSOR_UPPERFATAL:
+                case PLDM_SENSOR_UPPERCRITICAL:
+                    return SensorThresholdCriticalHighGoingHigh;
+                case PLDM_SENSOR_UPPERWARNING:
+                    return SensorThresholdCriticalHighGoingLow;
+                case PLDM_SENSOR_NORMAL:
+                    return SensorThresholdWarningHighGoingLow;
+                case PLDM_SENSOR_LOWERWARNING:
+                    return SensorThresholdWarningLowGoingLow;
+                case PLDM_SENSOR_LOWERCRITICAL:
+                case PLDM_SENSOR_LOWERFATAL:
+                    return SensorThresholdCriticalLowGoingLow;
+                default:
+                    break;
+            }
+            break;
+        case PLDM_SENSOR_UPPERWARNING:
+            switch (eventState)
+            {
+                case PLDM_SENSOR_UPPERFATAL:
+                case PLDM_SENSOR_UPPERCRITICAL:
+                    return SensorThresholdCriticalHighGoingHigh;
+                case PLDM_SENSOR_UPPERWARNING:
+                    return SensorThresholdWarningHighGoingHigh;
+                case PLDM_SENSOR_NORMAL:
+                    return SensorThresholdWarningHighGoingLow;
+                case PLDM_SENSOR_LOWERWARNING:
+                    return SensorThresholdWarningLowGoingLow;
+                case PLDM_SENSOR_LOWERCRITICAL:
+                case PLDM_SENSOR_LOWERFATAL:
+                    return SensorThresholdCriticalLowGoingLow;
+                default:
+                    break;
+            }
+            break;
+        case PLDM_SENSOR_UNKNOWN:
+        case PLDM_SENSOR_NORMAL:
+            switch (eventState)
+            {
+                case PLDM_SENSOR_UPPERFATAL:
+                case PLDM_SENSOR_UPPERCRITICAL:
+                    return SensorThresholdCriticalHighGoingHigh;
+                case PLDM_SENSOR_UPPERWARNING:
+                    return SensorThresholdWarningHighGoingHigh;
+                case PLDM_SENSOR_NORMAL:
+                    break;
+                case PLDM_SENSOR_LOWERWARNING:
+                    return SensorThresholdWarningLowGoingLow;
+                case PLDM_SENSOR_LOWERCRITICAL:
+                case PLDM_SENSOR_LOWERFATAL:
+                    return SensorThresholdCriticalLowGoingLow;
+                default:
+                    break;
+            }
+            break;
+        case PLDM_SENSOR_LOWERWARNING:
+            switch (eventState)
+            {
+                case PLDM_SENSOR_UPPERFATAL:
+                case PLDM_SENSOR_UPPERCRITICAL:
+                    return SensorThresholdCriticalHighGoingHigh;
+                case PLDM_SENSOR_UPPERWARNING:
+                    return SensorThresholdWarningHighGoingHigh;
+                case PLDM_SENSOR_NORMAL:
+                    return SensorThresholdWarningLowGoingHigh;
+                case PLDM_SENSOR_LOWERWARNING:
+                    return SensorThresholdWarningLowGoingLow;
+                case PLDM_SENSOR_LOWERCRITICAL:
+                case PLDM_SENSOR_LOWERFATAL:
+                    return SensorThresholdCriticalLowGoingLow;
+                default:
+                    break;
+            }
+            break;
+        case PLDM_SENSOR_LOWERCRITICAL:
+        case PLDM_SENSOR_LOWERFATAL:
+            switch (eventState)
+            {
+                case PLDM_SENSOR_UPPERFATAL:
+                case PLDM_SENSOR_UPPERCRITICAL:
+                    return SensorThresholdCriticalHighGoingHigh;
+                case PLDM_SENSOR_UPPERWARNING:
+                    return SensorThresholdWarningHighGoingHigh;
+                case PLDM_SENSOR_NORMAL:
+                    return SensorThresholdWarningLowGoingHigh;
+                case PLDM_SENSOR_LOWERWARNING:
+                    return SensorThresholdCriticalLowGoingHigh;
+                case PLDM_SENSOR_LOWERCRITICAL:
+                case PLDM_SENSOR_LOWERFATAL:
+                    return SensorThresholdCriticalLowGoingLow;
+                default:
+                    break;
+            }
+            break;
+    }
+    return std::string{};
+}
+
+} // namespace platform_mc
+} // namespace pldm
diff --git a/platform-mc/event_manager.hpp b/platform-mc/event_manager.hpp
new file mode 100644
index 0000000..170a55b
--- /dev/null
+++ b/platform-mc/event_manager.hpp
@@ -0,0 +1,130 @@
+#pragma once
+
+#include "libpldm/platform.h"
+#include "libpldm/pldm.h"
+
+#include "common/types.hpp"
+#include "numeric_sensor.hpp"
+#include "pldmd/dbus_impl_requester.hpp"
+#include "requester/handler.hpp"
+#include "terminus.hpp"
+#include "terminus_manager.hpp"
+
+#define PLDM_OEM_EVENT_CLASS_0xFA 0xFA
+
+namespace pldm
+{
+namespace platform_mc
+{
+
+const std::string SensorThresholdCriticalHighGoingHigh{
+    "OpenBMC.0.2.SensorThresholdCriticalHighGoingHigh"};
+const std::string SensorThresholdCriticalHighGoingLow{
+    "OpenBMC.0.2.SensorThresholdCriticalHighGoingLow"};
+const std::string SensorThresholdCriticalLowGoingHigh{
+    "OpenBMC.0.2.SensorThresholdCriticalLowGoingHigh"};
+const std::string SensorThresholdCriticalLowGoingLow{
+    "OpenBMC.0.2.SensorThresholdCriticalLowGoingLow"};
+const std::string SensorThresholdWarningHighGoingHigh{
+    "OpenBMC.0.2.SensorThresholdWarningHighGoingHigh"};
+const std::string SensorThresholdWarningHighGoingLow{
+    "OpenBMC.0.2.SensorThresholdWarningHighGoingLow"};
+const std::string SensorThresholdWarningLowGoingHigh{
+    "OpenBMC.0.2.SensorThresholdWarningLowGoingHigh"};
+const std::string SensorThresholdWarningLowGoingLow{
+    "OpenBMC.0.2.SensorThresholdWarningLowGoingLow"};
+
+/**
+ * @brief EventManager
+ *
+ * This class manages PLDM events from terminus. The function includes providing
+ * the API for process event data and using phosphor-logging API to log the
+ * event.
+ *
+ */
+class EventManager
+{
+  public:
+    EventManager() = delete;
+    EventManager(const EventManager&) = delete;
+    EventManager(EventManager&&) = delete;
+    EventManager& operator=(const EventManager&) = delete;
+    EventManager& operator=(EventManager&&) = delete;
+    virtual ~EventManager() = default;
+
+    explicit EventManager(
+        TerminusManager& terminusManager,
+        std::map<mctp_eid_t, std::shared_ptr<Terminus>>& termini) :
+        terminusManager(terminusManager),
+        termini(termini){};
+
+    /** @brief Handle platform event
+     *
+     *  @param[in] tid - tid where the event is from
+     *  @param[in] eventClass - event class
+     *  @param[in] eventData - event data
+     *  @param[in] eventDataSize - size of event data
+     *  @return PLDM completion code
+     *
+     */
+    int handlePlatformEvent(tid_t tid, uint8_t eventClass,
+                            const uint8_t* eventData, size_t eventDataSize);
+
+    std::string getSensorThresholdMessageId(uint8_t previousEventState,
+                                            uint8_t eventState);
+
+    /** @brief A Coroutine to poll all events from terminus
+     *
+     *  @param[in] dstTid - the destination TID
+     */
+    requester::Coroutine pollForPlatformEventTask(tid_t tid);
+
+  protected:
+    /** @brief Send pollForPlatformEventMessage and return response
+     *
+     *  @param[in] tid
+     *  @param[in] transferOpFlag
+     *  @param[in] dataTransferHandle
+     *  @param[in] eventIdToAcknowledge
+     *  @param[out] completionCode
+     *  @param[out] eventTid
+     *  @param[out] eventId
+     *  @param[out] nextDataTransferHandle
+     *  @param[out] transferFlag
+     *  @param[out] eventClass
+     *  @param[out] eventDataSize
+     *  @param[out] eventData
+     *  @param[out] eventDataIntegrityChecksum
+     *  @return coroutine return_value - PLDM completion code
+     *
+     */
+    requester::Coroutine pollForPlatformEventMessage(
+        tid_t tid, uint8_t transferOperationFlag, uint32_t dataTransferHandle,
+        uint16_t eventIdToAcknowledge, uint8_t& completionCode,
+        uint8_t& eventTid, uint16_t& eventId, uint32_t& nextDataTransferHandle,
+        uint8_t& transferFlag, uint8_t& eventClass, uint32_t& eventDataSize,
+        uint8_t*& eventData, uint32_t& eventDataIntegrityChecksum);
+
+    virtual int processCperEvent(const uint8_t* eventData,
+                                 size_t eventDataSize);
+
+    int createCperDumpEntry(const std::string& dataType,
+                            const std::string& dataPath);
+
+    int processNumericSensorEvent(tid_t tid, uint16_t sensorId,
+                                  const uint8_t* sensorData,
+                                  size_t sensorDataLength);
+
+    virtual int createSensorThresholdLogEntry(const std::string& messageID,
+                                              const std::string& sensorName,
+                                              const double reading,
+                                              const double threshold);
+
+    /** @brief Reference of terminusManager */
+    TerminusManager& terminusManager;
+
+    /** @brief List of discovered termini */
+    std::map<tid_t, std::shared_ptr<Terminus>>& termini;
+};
+} // namespace platform_mc
+} // namespace pldm
diff --git a/platform-mc/manager.hpp b/platform-mc/manager.hpp
index 69464e3..8f8d27a 100644
--- a/platform-mc/manager.hpp
+++ b/platform-mc/manager.hpp
@@ -4,6 +4,7 @@
 
 #include "common/instance_id.hpp"
 #include "common/types.hpp"
+#include "event_manager.hpp"
 #include "platform_manager.hpp"
 #include "requester/handler.hpp"
 #include "requester/mctp_endpoint_discovery.hpp"
@@ -35,9 +36,10 @@ class Manager : public pldm::MctpDiscoveryHandlerIntf
     explicit Manager(sdeventplus::Event& event,
                      requester::Handler<requester::Request>& handler,
                      pldm::InstanceIdDb& instanceIdDb) :
-        terminusManager(event, handler, instanceIdDb, termini, this),
+        terminusManager(event, handler, instanceIdDb, termini, LOCAL_EID, this),
         platformManager(terminusManager, termini),
-        sensorManager(event, terminusManager, termini)
+        sensorManager(event, terminusManager, termini, this),
+        eventManager(terminusManager, termini)
     {}
 
     requester::Coroutine beforeDiscoverTerminus()
@@ -71,6 +73,55 @@ class Manager : public pldm::MctpDiscoveryHandlerIntf
         sensorManager.stopPolling(tid);
     }
 
+    int handleCperEvent(const pldm_msg* request, size_t payloadLength,
+                        uint8_t /* formatVersion */, uint8_t tid,
+                        size_t eventDataOffset)
+    {
+        auto eventData = reinterpret_cast<const uint8_t*>(request->payload) +
+                         eventDataOffset;
+        auto eventDataSize = payloadLength - eventDataOffset;
+        eventManager.handlePlatformEvent(tid, PLDM_OEM_EVENT_CLASS_0xFA,
+                                         eventData, eventDataSize);
+        return PLDM_SUCCESS;
+    }
+
+    int handlePldmMessagePollEvent(const pldm_msg* request,
+                                   size_t payloadLength,
+                                   uint8_t /* formatVersion */, uint8_t tid,
+                                   size_t eventDataOffset)
+    {
+        auto eventData = reinterpret_cast<const uint8_t*>(request->payload) +
+                         eventDataOffset;
+        auto eventDataSize = payloadLength - eventDataOffset;
+        eventManager.handlePlatformEvent(tid, PLDM_MESSAGE_POLL_EVENT,
+                                         eventData, eventDataSize);
+        return PLDM_SUCCESS;
+    }
+
+    int handleSensorEvent(const pldm_msg* request, size_t payloadLength,
+                          uint8_t /* formatVersion */, uint8_t tid,
+                          size_t eventDataOffset)
+    {
+        auto eventData = reinterpret_cast<const uint8_t*>(request->payload) +
+                         eventDataOffset;
+        auto eventDataSize = payloadLength - eventDataOffset;
+        eventManager.handlePlatformEvent(tid, PLDM_SENSOR_EVENT, eventData,
+                                         eventDataSize);
+        return PLDM_SUCCESS;
+    }
+
+    requester::Coroutine pollForPlatformEvent(tid_t tid)
+    {
+        auto it = termini.find(tid);
+        if (it != termini.end())
+        {
+            auto& terminus = it->second;
+            co_await eventManager.pollForPlatformEventTask(tid);
+            terminus->pollEvent = false;
+        }
+        co_return PLDM_SUCCESS;
+    }
+
   private:
     /** @brief List of discovered termini */
     std::map<tid_t, std::shared_ptr<Terminus>> termini{};
@@ -78,6 +129,7 @@ class Manager : public pldm::MctpDiscoveryHandlerIntf
     TerminusManager terminusManager;
     PlatformManager platformManager;
     SensorManager sensorManager;
+    EventManager eventManager;
 };
 } // namespace platform_mc
 } // namespace pldm
diff --git a/platform-mc/platform_manager.cpp b/platform-mc/platform_manager.cpp
index f4298e0..26883be 100644
--- a/platform-mc/platform_manager.cpp
+++ b/platform-mc/platform_manager.cpp
@@ -9,6 +9,10 @@ namespace platform_mc
 
 requester::Coroutine PlatformManager::initTerminus()
 {
+/* DSP0248 section16.9 EventMessageBufferSize Command, the default message
+ * buffer size is 256 bytes*/
+#define DEFAULT_MESSAGE_BUFFER_SIZE 256
+
     for (auto& [tid, terminus] : termini)
     {
         if (terminus->initalized)
@@ -18,11 +22,82 @@ requester::Coroutine PlatformManager::initTerminus()
 
         if (terminus->doesSupport(PLDM_PLATFORM))
         {
-            auto rc = co_await getPDRs(terminus);
+            uint16_t terminusMaxBufferSize = terminus->maxBufferSize;
+            auto rc = co_await eventMessageBufferSize(
+                tid, terminus->maxBufferSize, terminusMaxBufferSize);
+            if (rc)
+            {
+                terminusMaxBufferSize = DEFAULT_MESSAGE_BUFFER_SIZE;
+            }
+
+            terminus->maxBufferSize = std::min(terminus->maxBufferSize,
+                                               terminusMaxBufferSize);
+
+            uint8_t synchronyConfiguration = 0;
+            uint8_t numberEventClassReturned = 0;
+            std::vector<uint8_t> eventClass{};
+            rc = co_await eventMessageSupported(
+                tid, 1, synchronyConfiguration,
+                terminus->synchronyConfigurationSupported,
+                numberEventClassReturned, eventClass);
+            if (rc)
+            {
+                synchronyConfiguration = 0;
+                terminus->synchronyConfigurationSupported.byte = 0;
+            }
+
+            rc = co_await getPDRs(terminus);
             if (!rc)
             {
                 terminus->parsePDRs();
             }
+
+            pldm_event_message_global_enable eventMessageGlobalEnable =
+                PLDM_EVENT_MESSAGE_GLOBAL_DISABLE;
+            uint16_t heartbeatTimer = 0;
+            /* Use PLDM_EVENT_MESSAGE_GLOBAL_ENABLE_ASYNC_KEEP_ALIVE when
+             * for eventMessageGlobalEnable when the terminus supports that type
+             */
+            if (terminus->synchronyConfigurationSupported.byte &
+                (1 << PLDM_EVENT_MESSAGE_GLOBAL_ENABLE_ASYNC_KEEP_ALIVE))
+            {
+                heartbeatTimer = 0x78;
+                eventMessageGlobalEnable =
+                    PLDM_EVENT_MESSAGE_GLOBAL_ENABLE_ASYNC_KEEP_ALIVE;
+            }
+            /* Use PLDM_EVENT_MESSAGE_GLOBAL_ENABLE_ASYNC when
+             * for eventMessageGlobalEnable when the terminus does not support
+             * PLDM_EVENT_MESSAGE_GLOBAL_ENABLE_ASYNC_KEEP_ALIVE
+             * and supports PLDM_EVENT_MESSAGE_GLOBAL_ENABLE_ASYNC type
+             */
+            else if (terminus->synchronyConfigurationSupported.byte &
+                     (1 << PLDM_EVENT_MESSAGE_GLOBAL_ENABLE_ASYNC))
+            {
+                eventMessageGlobalEnable =
+                    PLDM_EVENT_MESSAGE_GLOBAL_ENABLE_ASYNC;
+            }
+            /* Only use PLDM_EVENT_MESSAGE_GLOBAL_ENABLE_POLLING
+             * for eventMessageGlobalEnable when the terminus only supports
+             * this type
+             */
+            else if (terminus->synchronyConfigurationSupported.byte &
+                     (1 << PLDM_EVENT_MESSAGE_GLOBAL_ENABLE_POLLING))
+            {
+                eventMessageGlobalEnable =
+                    PLDM_EVENT_MESSAGE_GLOBAL_ENABLE_POLLING;
+            }
+
+            if (eventMessageGlobalEnable != PLDM_EVENT_MESSAGE_GLOBAL_DISABLE)
+            {
+                rc = co_await setEventReceiver(
+                    tid, eventMessageGlobalEnable,
+                    PLDM_TRANSPORT_PROTOCOL_TYPE_MCTP, heartbeatTimer);
+                if (rc)
+                {
+                    std::cerr << "setEventReceiver failed, rc="
+                              << static_cast<unsigned>(rc) << "\n";
+                }
+            }
         }
         terminus->initalized = true;
     }
@@ -220,5 +295,110 @@ requester::Coroutine PlatformManager::getPDRRepositoryInfo(
     co_return completionCode;
 }
 
+requester::Coroutine PlatformManager::eventMessageBufferSize(
+    tid_t tid, uint16_t receiverMaxBufferSize, uint16_t& terminusBufferSize)
+{
+    Request request(sizeof(pldm_msg_hdr) +
+                    PLDM_EVENT_MESSAGE_BUFFER_SIZE_REQ_BYTES);
+    auto requestMsg = reinterpret_cast<pldm_msg*>(request.data());
+    auto rc = encode_event_message_buffer_size_req(0, receiverMaxBufferSize,
+                                                   requestMsg);
+    if (rc)
+    {
+        co_return rc;
+    }
+
+    const pldm_msg* responseMsg = NULL;
+    size_t responseLen = 0;
+    rc = co_await terminusManager.SendRecvPldmMsg(tid, request, &responseMsg,
+                                                  &responseLen);
+    if (rc)
+    {
+        co_return rc;
+    }
+
+    uint8_t completionCode;
+    rc = decode_event_message_buffer_size_resp(
+        responseMsg, responseLen, &completionCode, &terminusBufferSize);
+    if (rc)
+    {
+        co_return rc;
+    }
+    co_return completionCode;
+}
+
+requester::Coroutine PlatformManager::setEventReceiver(
+    tid_t tid, pldm_event_message_global_enable eventMessageGlobalEnable,
+    pldm_transport_protocol_type protocalType, uint16_t heartbeatTimer)
+{
+    Request request(sizeof(pldm_msg_hdr) + PLDM_SET_EVENT_RECEIVER_REQ_BYTES);
+    auto requestMsg = reinterpret_cast<pldm_msg*>(request.data());
+    auto rc = encode_set_event_receiver_req(
+        0, eventMessageGlobalEnable, protocalType,
+        terminusManager.getLocalEid(), heartbeatTimer, requestMsg);
+    if (rc)
+    {
+        co_return rc;
+    }
+
+    const pldm_msg* responseMsg = NULL;
+    size_t responseLen = 0;
+    rc = co_await terminusManager.SendRecvPldmMsg(tid, request, &responseMsg,
+                                                  &responseLen);
+    if (rc)
+    {
+        co_return rc;
+    }
+
+    uint8_t completionCode;
+    rc = decode_set_event_receiver_resp(responseMsg, responseLen,
+                                        &completionCode);
+    if (rc)
+    {
+        co_return rc;
+    }
+    co_return completionCode;
+}
+
+requester::Coroutine PlatformManager::eventMessageSupported(
+    tid_t tid, uint8_t formatVersion, uint8_t& synchronyConfiguration,
+    bitfield8_t& synchronyConfigurationSupported,
+    uint8_t& numberEventClassReturned, std::vector<uint8_t>& eventClass)
+{
+    Request request(sizeof(pldm_msg_hdr) +
+                    PLDM_EVENT_MESSAGE_SUPPORTED_REQ_BYTES);
+    auto requestMsg = reinterpret_cast<pldm_msg*>(request.data());
+    auto rc = encode_event_message_supported_req(0, formatVersion, requestMsg);
+    if (rc)
+    {
+        co_return rc;
+    }
+
+    const pldm_msg* responseMsg = NULL;
+    size_t responseLen = 0;
+    rc = co_await terminusManager.SendRecvPldmMsg(tid, request, &responseMsg,
+                                                  &responseLen);
+    if (rc)
+    {
+        co_return rc;
+    }
+
+    uint8_t completionCode = 0;
+    uint8_t eventClassReturned[std::numeric_limits<uint8_t>::max()];
+    uint8_t eventClassCount = std::numeric_limits<uint8_t>::max();
+
+    rc = decode_event_message_supported_resp(
+        responseMsg, responseLen, &completionCode, &synchronyConfiguration,
+        &synchronyConfigurationSupported, &numberEventClassReturned,
+        eventClassReturned, eventClassCount);
+    if (rc)
+    {
+        co_return rc;
+    }
+
+    eventClass.insert(eventClass.end(), eventClassReturned,
+                      eventClassReturned + numberEventClassReturned);
+    co_return completionCode;
+}
 } // namespace platform_mc
 } // namespace pldm
diff --git a/platform-mc/platform_manager.hpp b/platform-mc/platform_manager.hpp
index ee8a498..11c178a 100644
--- a/platform-mc/platform_manager.hpp
+++ b/platform-mc/platform_manager.hpp
@@ -88,7 +88,51 @@ class PlatformManager
                                               uint32_t& repositorySize,
                                               uint32_t& largestRecordSize);
 
-    /** @brief reference of terminusManager */
+    /** @brief Send setEventReceiver command to destination EID.
+     *
+     *  @param[in] tid - Destination TID
+     *  @param[in] eventMessageGlobalEnable - Enable/disable event message
+     * generation from the terminus
+     *  @param[in] eventReceiverEid - The EID of eventReceiver that terminus
+     * should send event message to
+     *  @param[in] protocalType - Provided in the request to help the responder
+     * verify that the content of the eventReceiverAddressInfo field
+     *  @param[in] heartbeatTimer - Amount of time in seconds after each
+     * elapsing of which the terminus shall emit a heartbeat event.
+     *  @return coroutine return_value - PLDM completion code
+     */
+    requester::Coroutine setEventReceiver(
+        tid_t tid, pldm_event_message_global_enable eventMessageGlobalEnable,
+        pldm_transport_protocol_type protocalType, uint16_t heartbeatTimer);
+
+    /** @brief  send eventMessageBufferSize
+     *  @param[in] tid - Destination TID
+     *  @param[in] receiverMaxBufferSize
+     *  @param[out] terminusBufferSize
+     *  @return coroutine return_value - PLDM completion code
+     */
+    requester::Coroutine eventMessageBufferSize(tid_t tid,
+                                                uint16_t receiverMaxBufferSize,
+                                                uint16_t& terminusBufferSize);
+
+    /** @brief  send eventMessageSupprted
+     *  @param[in] tid - Destination TID
+     *  @param[in] formatVersion - version of the event format
+     *  @param[out] synchronyConfiguration - messaging style most recently
+     * configured via the setEventReceiver command
+     *  @param[out] synchronyConfigurationSupported - event messaging styles
+     * supported by the terminus
+     *  @param[out] numerEventClassReturned - number of eventClass enumerated
+     * bytes
+     *  @param[out] eventClass - vector of eventClass the device can generate
+     *  @return coroutine return_value - PLDM completion code
+     */
+    requester::Coroutine eventMessageSupported(
+        tid_t tid, uint8_t formatVersion, uint8_t& synchronyConfiguration,
+        bitfield8_t& synchronyConfigurationSupported,
+        uint8_t& numerEventClassReturned, std::vector<uint8_t>& eventClass);
+
+    /** reference of TerminusManager for sending PLDM request to terminus*/
     TerminusManager& terminusManager;
 
     /** @brief Managed termini list */
diff --git a/platform-mc/sensor_manager.cpp b/platform-mc/sensor_manager.cpp
index 73f5702..21c3a3c 100644
--- a/platform-mc/sensor_manager.cpp
+++ b/platform-mc/sensor_manager.cpp
@@ -1,5 +1,6 @@
 #include "sensor_manager.hpp"
 
+#include "manager.hpp"
 #include "terminus_manager.hpp"
 
 #include <phosphor-logging/lg2.hpp>
@@ -13,11 +14,11 @@ using namespace std::chrono;
 
 SensorManager::SensorManager(
     sdeventplus::Event& event, TerminusManager& terminusManager,
-    std::map<tid_t, std::shared_ptr<Terminus>>& termini, bool verbose,
-    const std::filesystem::path& configJson) :
+    std::map<tid_t, std::shared_ptr<Terminus>>& termini, Manager* manager,
+    bool verbose, const std::filesystem::path& configJson) :
     event(event),
     terminusManager(terminusManager), termini(termini),
-    pollingTime(SENSOR_POLLING_TIME), verbose(verbose)
+    pollingTime(SENSOR_POLLING_TIME), verbose(verbose), manager(manager)
 {
     // default priority sensor name spaces
     prioritySensorNameSpaces.emplace_back(
@@ -182,6 +183,13 @@ requester::Coroutine SensorManager::doSensorPollingTask(tid_t tid)
             co_return PLDM_SUCCESS;
         }
 
+        auto& terminus = termini[tid];
+
+        if (manager && terminus->pollEvent)
+        {
+            co_await manager->pollForPlatformEvent(tid);
+        }
+
         // poll priority Sensors
         for (auto& sensor : prioritySensors[tid])
         {
diff --git a/platform-mc/sensor_manager.hpp b/platform-mc/sensor_manager.hpp
index ef9a79e..6bd3ac5 100644
--- a/platform-mc/sensor_manager.hpp
+++ b/platform-mc/sensor_manager.hpp
@@ -32,7 +32,7 @@ class SensorManager
 
     explicit SensorManager(
         sdeventplus::Event& event, TerminusManager& terminusManager,
-        std::map<tid_t, std::shared_ptr<Terminus>>& termini,
+        std::map<tid_t, std::shared_ptr<Terminus>>& termini, Manager* manager,
         bool verbose = false,
         const std::filesystem::path& configJson = PLDM_T2_CONFIG_JSON);
 
@@ -100,6 +100,9 @@ class SensorManager
     /** @brief round robin sensor list */
     std::map<tid_t, std::queue<std::shared_ptr<NumericSensor>>>
         roundRobinSensors;
+
+    /** @brief pointer to Manager */
+    Manager* manager;
 };
 } // namespace platform_mc
 } // namespace pldm
diff --git a/platform-mc/terminus.cpp b/platform-mc/terminus.cpp
index 0901f28..fd54e3b 100644
--- a/platform-mc/terminus.cpp
+++ b/platform-mc/terminus.cpp
@@ -8,9 +8,13 @@ namespace pldm
 {
 namespace platform_mc
 {
+/* default the max message buffer size BMC supported to 4K bytes */
+#define MAX_MESSAGE_BUFFER_SIZE 4096
 
 Terminus::Terminus(tid_t tid, uint64_t supportedTypes) :
-    initalized(false), tid(tid), supportedTypes(supportedTypes)
+    initalized(false), maxBufferSize(MAX_MESSAGE_BUFFER_SIZE),
+    synchronyConfigurationSupported(0), pollEvent(false), tid(tid),
+    supportedTypes(supportedTypes)
 {
     inventoryPath = "/xyz/openbmc_project/inventory/Item/Board/PLDM_Device_" +
                     std::to_string(tid);
diff --git a/platform-mc/terminus.hpp b/platform-mc/terminus.hpp
index 9e3d36e..0aa3c92 100644
--- a/platform-mc/terminus.hpp
+++ b/platform-mc/terminus.hpp
@@ -62,6 +62,18 @@ class Terminus
     /** @brief A flag to indicate if terminus has been initialzed */
     bool initalized;
 
+    /** @brief maximum message buffer size the terminus can send and receive */
+    uint16_t maxBufferSize;
+
+    /** @brief This value indicates the event messaging styles supported by the
+     * terminus */
+    bitfield8_t synchronyConfigurationSupported;
+
+    /** @brief The flag indicates that the terminus FIFO contains a large
+     * message that will require a multipart transfer via the
+     * PollForPlatformEvent command */
+    bool pollEvent;
+
     /** @brief A list of numericSensors */
     std::vector<std::shared_ptr<NumericSensor>> numericSensors{};
 
diff --git a/platform-mc/terminus_manager.hpp b/platform-mc/terminus_manager.hpp
index 9722c5d..15d643b 100644
--- a/platform-mc/terminus_manager.hpp
+++ b/platform-mc/terminus_manager.hpp
@@ -44,10 +44,11 @@ class TerminusManager
         sdeventplus::Event& event,
         requester::Handler<requester::Request>& handler,
         pldm::InstanceIdDb& instanceIdDb,
-        std::map<tid_t, std::shared_ptr<Terminus>>& termini, Manager* manager) :
+        std::map<tid_t, std::shared_ptr<Terminus>>& termini,
+        mctp_eid_t localEid, Manager* manager) :
         event(event),
         handler(handler), instanceIdDb(instanceIdDb), termini(termini),
-        tidPool(tidPoolSize, false), manager(manager)
+        localEid(localEid), tidPool(tidPoolSize, false), manager(manager)
     {
         // DSP0240 v1.1.0 table-8, special value: 0,0xFF = reserved
         tidPool[0] = true;
@@ -101,6 +102,15 @@ class TerminusManager
     std::optional<tid_t> mapTid(const MctpInfo& mctpInfo, tid_t tid);
     bool unmapTid(const tid_t& tid);
 
+    /** @brief getter of local EID
+     *
+     *  @return uint8_t - local EID
+     */
+    mctp_eid_t getLocalEid()
+    {
+        return localEid;
+    }
+
   private:
     /** @brief The coroutine task execute by discoverMctpTerminus()
      *
@@ -155,6 +165,9 @@ class TerminusManager
     /** @brief Managed termini list */
     std::map<tid_t, std::shared_ptr<Terminus>>& termini;
 
+    /** @brief local EID */
+    mctp_eid_t localEid;
+
     /** @brief tables for maintaining assigned TID */
     std::vector<bool> tidPool;
     std::map<tid_t, SupportedTransportLayer> transportLayerTable;
diff --git a/platform-mc/test/event_manager_test.cpp b/platform-mc/test/event_manager_test.cpp
new file mode 100644
index 0000000..a3bc204
--- /dev/null
+++ b/platform-mc/test/event_manager_test.cpp
@@ -0,0 +1,418 @@
+#include "libpldm/base.h"
+#include "libpldm/entity.h"
+#include "libpldm/platform.h"
+
+#include "common/instance_id.hpp"
+#include "common/types.hpp"
+#include "mock_event_manager.hpp"
+#include "mock_terminus_manager.hpp"
+#include "platform-mc/platform_manager.hpp"
+#include "platform-mc/terminus_manager.hpp"
+#include "test/test_instance_id.hpp"
+
+#include <gtest/gtest.h>
+
+using ::testing::_;
+using ::testing::Return;
+
+using namespace pldm::platform_mc;
+
+class EventManagerTest : public testing::Test
+{
+  protected:
+    EventManagerTest() :
+        bus(pldm::utils::DBusHandler::getBus()),
+        event(sdeventplus::Event::get_default()), instanceIdDb(),
+        reqHandler(pldmTransport, event, instanceIdDb, false, seconds(1), 2,
+                   milliseconds(100)),
+        terminusManager(event, reqHandler, instanceIdDb, termini, nullptr),
+        eventManager(terminusManager, termini),
+        platformManager(terminusManager, termini)
+    {}
+
+    PldmTransport* pldmTransport = nullptr;
+    sdbusplus::bus::bus& bus;
+    sdeventplus::Event event;
+    TestInstanceIdDb instanceIdDb;
+    pldm::requester::Handler<pldm::requester::Request> reqHandler;
+    MockTerminusManager terminusManager;
+    MockEventManager eventManager;
+    PlatformManager platformManager;
+    std::map<pldm::tid_t, std::shared_ptr<Terminus>> termini{};
+};
+
+TEST_F(EventManagerTest, processNumericSensorEventTest)
+{
+#define SENSOR_READING 50
+#define WARNING_HIGH 45
+    pldm::tid_t tid = 1;
+    termini[tid] =
+        std::make_shared<Terminus>(tid, 1 << PLDM_BASE | 1 << PLDM_PLATFORM);
+    std::vector<uint8_t> pdr1{
+        0x1,
+        0x0,
+        0x0,
+        0x0,                         // record handle
+        0x1,                         // PDRHeaderVersion
+        PLDM_NUMERIC_SENSOR_PDR,     // PDRType
+        0x0,
+        0x0,                         // recordChangeNumber
+        PLDM_PDR_NUMERIC_SENSOR_PDR_MIN_LENGTH,
+        0,                           // dataLength
+        0,
+        0,                           // PLDMTerminusHandle
+        0x1,
+        0x0,                         // sensorID=1
+        PLDM_ENTITY_POWER_SUPPLY,
+        0,                           // entityType=Power Supply(120)
+        1,
+        0,                           // entityInstanceNumber
+        1,
+        0,                           // containerID=1
+        PLDM_NO_INIT,                // sensorInit
+        false,                       // sensorAuxiliaryNamesPDR
+        PLDM_SENSOR_UNIT_DEGRESS_C,  // baseUint(2)=degrees C
+        0,                           // unitModifier = 0
+        0,                           // rateUnit
+        0,                           // baseOEMUnitHandle
+        0,                           // auxUnit
+        0,                           // auxUnitModifier
+        0,                           // auxRateUnit
+        0,                           // rel
+        0,                           // auxOEMUnitHandle
+        true,                        // isLinear
+        PLDM_SENSOR_DATA_SIZE_UINT8, // sensorDataSize
+        0,
+        0,
+        0x80,
+        0x3f, // resolution=1.0
+        0,
+        0,
+        0,
+        0, // offset=0
+        0,
+        0, // accuracy
+        0, // plusTolerance
+        0, // minusTolerance
+        2, // hysteresis = 2
+        0, // supportedThresholds
+        0, // thresholdAndHysteresisVolatility
+        0,
+        0,
+        0x80,
+        0x3f, // stateTransistionInterval=1.0
+        0,
+        0,
+        0x80,
+        0x3f,                          // updateInverval=1.0
+        255,                           // maxReadable
+        0,                             // minReadable
+        PLDM_RANGE_FIELD_FORMAT_UINT8, // rangeFieldFormat
+        0x18,                          // rangeFieldsupport
+        0,                             // nominalValue
+        0,                             // normalMax
+        0,                             // normalMin
+        WARNING_HIGH,                  // warningHigh
+        20,                            // warningLow
+        60,                            // criticalHigh
+        10,                            // criticalLow
+        0,                             // fatalHigh
+        0                              // fatalLow
+    };
+
+    // add dummy numeric sensor
+    termini[tid]->pdrs.emplace_back(pdr1);
+    auto rc = termini[tid]->parsePDRs();
+    EXPECT_EQ(true, rc);
+    EXPECT_EQ(1, termini[tid]->numericSensors.size());
+
+    uint8_t platformEventStatus = 0;
+
+    EXPECT_CALL(eventManager, createSensorThresholdLogEntry(
+                                  SensorThresholdWarningHighGoingHigh, _,
+                                  SENSOR_READING, WARNING_HIGH))
+        .Times(1)
+        .WillRepeatedly(Return(PLDM_SUCCESS));
+    std::vector<uint8_t> eventData{0x1,
+                                   0x0, // sensor id
+                                   PLDM_NUMERIC_SENSOR_STATE,
+                                   PLDM_SENSOR_UPPERWARNING,
+                                   PLDM_SENSOR_NORMAL,
+                                   PLDM_SENSOR_DATA_SIZE_UINT8,
+                                   SENSOR_READING};
+    rc = eventManager.handlePlatformEvent(tid, PLDM_SENSOR_EVENT,
+                                          eventData.data(), eventData.size());
+    EXPECT_EQ(PLDM_SUCCESS, rc);
+    EXPECT_EQ(PLDM_EVENT_NO_LOGGING, platformEventStatus);
+}
+
+TEST_F(EventManagerTest, getSensorThresholdMessageIdTest)
+{
+    std::string messageId{};
+    messageId = eventManager.getSensorThresholdMessageId(PLDM_SENSOR_UNKNOWN,
+                                                         PLDM_SENSOR_NORMAL);
+    EXPECT_EQ(messageId, std::string{});
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_UNKNOWN, PLDM_SENSOR_LOWERWARNING);
+    EXPECT_EQ(messageId, SensorThresholdWarningLowGoingLow);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_UNKNOWN, PLDM_SENSOR_LOWERCRITICAL);
+    EXPECT_EQ(messageId, SensorThresholdCriticalLowGoingLow);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_UNKNOWN, PLDM_SENSOR_UPPERWARNING);
+    EXPECT_EQ(messageId, SensorThresholdWarningHighGoingHigh);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_UNKNOWN, PLDM_SENSOR_UPPERCRITICAL);
+    EXPECT_EQ(messageId, SensorThresholdCriticalHighGoingHigh);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_NORMAL, PLDM_SENSOR_LOWERWARNING);
+    EXPECT_EQ(messageId, SensorThresholdWarningLowGoingLow);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_LOWERWARNING, PLDM_SENSOR_LOWERCRITICAL);
+    EXPECT_EQ(messageId, SensorThresholdCriticalLowGoingLow);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_LOWERCRITICAL, PLDM_SENSOR_LOWERWARNING);
+    EXPECT_EQ(messageId, SensorThresholdCriticalLowGoingHigh);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_LOWERWARNING, PLDM_SENSOR_NORMAL);
+    EXPECT_EQ(messageId, SensorThresholdWarningLowGoingHigh);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_NORMAL, PLDM_SENSOR_UPPERWARNING);
+    EXPECT_EQ(messageId, SensorThresholdWarningHighGoingHigh);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_UPPERWARNING, PLDM_SENSOR_UPPERCRITICAL);
+    EXPECT_EQ(messageId, SensorThresholdCriticalHighGoingHigh);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_UPPERCRITICAL, PLDM_SENSOR_UPPERWARNING);
+    EXPECT_EQ(messageId, SensorThresholdCriticalHighGoingLow);
+
+    messageId = eventManager.getSensorThresholdMessageId(
+        PLDM_SENSOR_UPPERWARNING, PLDM_SENSOR_NORMAL);
+    EXPECT_EQ(messageId, SensorThresholdWarningHighGoingLow);
+}
+
+TEST_F(EventManagerTest, SetEventReceiverTest)
+{
+    // Add terminus
+    auto mappedTid = terminusManager.mapTid(pldm::MctpInfo(1, "", "", 1));
+    auto tid = mappedTid.value();
+    termini[tid] =
+        std::make_shared<Terminus>(tid, 1 << PLDM_BASE | 1 << PLDM_PLATFORM);
+    auto terminus = termini[tid];
+
+    // queue eventMessageBufferSize response(bufferSize=32)
+    const size_t eventMessageBufferSizeRespLen = 3;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + eventMessageBufferSizeRespLen>
+        eventMessageBufferSizeResp{0x0, 0x02, 0x0d, PLDM_SUCCESS, 32, 0};
+    auto rc = terminusManager.enqueueResponse(
+        (pldm_msg*)eventMessageBufferSizeResp.data(),
+        sizeof(eventMessageBufferSizeResp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    // queue eventMessageSupported response
+    const size_t eventMessageSupportedLen = 7;
+    PLDM_GET_PDR_REPOSITORY_INFO_RESP_BYTES;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + eventMessageSupportedLen>
+        eventMessageSupportedResp{0x0,  0x02, 0x0c, PLDM_SUCCESS,
+                                  0x0,  // synchronyConfiguration
+                                  0x06, // synchronyConfigurationSupported
+                                  3,    // numberEventClassReturned
+                                  0x0,  0x5,  0xfa};
+    rc = terminusManager.enqueueResponse(
+        (pldm_msg*)eventMessageSupportedResp.data(),
+        sizeof(eventMessageSupportedResp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    // queue getPDRRepositoryInfo response
+    const size_t getPDRRepositoryInfoLen =
+        PLDM_GET_PDR_REPOSITORY_INFO_RESP_BYTES;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + getPDRRepositoryInfoLen>
+        getPDRRepositoryInfoResp{
+            0x0, 0x02, 0x50, PLDM_SUCCESS,
+            0x0,                                     // repositoryState
+            0x0, 0x0,  0x0,  0x0,          0x0, 0x0, 0x0,
+            0x0, 0x0,  0x0,  0x0,          0x0, 0x0, // updateTime
+            0x0, 0x0,  0x0,  0x0,          0x0, 0x0, 0x0,
+            0x0, 0x0,  0x0,  0x0,          0x0, 0x0, // OEMUpdateTime
+            1,   0x0,  0x0,  0x0,                    // recordCount
+            0x0, 0x1,  0x0,  0x0,                    // repositorySize
+            59,  0x0,  0x0,  0x0,                    // largestRecordSize
+            0x0 // dataTransferHandleTimeout
+        };
+    rc = terminusManager.enqueueResponse(
+        (pldm_msg*)getPDRRepositoryInfoResp.data(),
+        sizeof(getPDRRepositoryInfoResp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    // queue getPDR responses
+    const size_t getPdrRespLen = 81;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + getPdrRespLen> getPdrResp{
+        0x0, 0x02, 0x51, PLDM_SUCCESS, 0x0, 0x0, 0x0, 0x0, // nextRecordHandle
+        0x0, 0x0, 0x0, 0x0, // nextDataTransferHandle
+        0x5,                // transferFlag
+        69, 0x0,            // responseCount
+        // numeric Sensor PDR
+        0x1, 0x0, 0x0,
+        0x0,                     // record handle
+        0x1,                     // PDRHeaderVersion
+        PLDM_NUMERIC_SENSOR_PDR, // PDRType
+        0x0,
+        0x0,                     // recordChangeNumber
+        PLDM_PDR_NUMERIC_SENSOR_PDR_FIXED_LENGTH +
+            PLDM_PDR_NUMERIC_SENSOR_PDR_VARIED_SENSOR_DATA_SIZE_MIN_LENGTH +
+            PLDM_PDR_NUMERIC_SENSOR_PDR_VARIED_RANGE_FIELD_MIN_LENGTH,
+        0,                             // dataLength
+        0,
+        0,                             // PLDMTerminusHandle
+        0x1,
+        0x0,                           // sensorID=1
+        120,
+        0,                             // entityType=Power Supply(120)
+        1,
+        0,                             // entityInstanceNumber
+        0x1,
+        0x0,                           // containerID=1
+        PLDM_NO_INIT,                  // sensorInit
+        false,                         // sensorAuxiliaryNamesPDR
+        PLDM_SENSOR_UNIT_DEGRESS_C,    // baseUint(2)=degrees C
+        1,                             // unitModifier = 1
+        0,                             // rateUnit
+        0,                             // baseOEMUnitHandle
+        0,                             // auxUnit
+        0,                             // auxUnitModifier
+        0,                             // auxRateUnit
+        0,                             // rel
+        0,                             // auxOEMUnitHandle
+        true,                          // isLinear
+        PLDM_SENSOR_DATA_SIZE_UINT8,   // sensorDataSize
+        0, 0, 0xc0,
+        0x3f,                          // resolution=1.5
+        0, 0, 0x80,
+        0x3f,                          // offset=1.0
+        0,
+        0,                             // accuracy
+        0,                             // plusTolerance
+        0,                             // minusTolerance
+        2,                             // hysteresis
+        0,                             // supportedThresholds
+        0,                             // thresholdAndHysteresisVolatility
+        0, 0, 0x80,
+        0x3f,                          // stateTransistionInterval=1.0
+        0, 0, 0x80,
+        0x3f,                          // updateInverval=1.0
+        255,                           // maxReadable
+        0,                             // minReadable
+        PLDM_RANGE_FIELD_FORMAT_UINT8, // rangeFieldFormat
+        0,                             // rangeFieldsupport
+        0,                             // nominalValue
+        0,                             // normalMax
+        0,                             // normalMin
+        0,                             // warningHigh
+        0,                             // warningLow
+        0,                             // criticalHigh
+        0,                             // criticalLow
+        0,                             // fatalHigh
+        0                              // fatalLow
+    };
+    rc = terminusManager.enqueueResponse((pldm_msg*)getPdrResp.data(),
+                                         sizeof(getPdrResp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    // queue SetEventReceiver response
+    const size_t SetEventReceiverLen = 1;
+    PLDM_GET_PDR_REPOSITORY_INFO_RESP_BYTES;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + SetEventReceiverLen>
+        SetEventReceiverResp{0x0, 0x02, 0x04, PLDM_SUCCESS};
+    rc = terminusManager.enqueueResponse((pldm_msg*)SetEventReceiverResp.data(),
+                                         sizeof(SetEventReceiverResp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    platformManager.initTerminus();
+    EXPECT_EQ(true, terminus->initalized);
+    EXPECT_EQ(1, terminus->pdrs.size());
+    EXPECT_EQ(1, terminus->numericSensors.size());
+    EXPECT_EQ(32, terminus->maxBufferSize);
+    EXPECT_EQ(0x06, terminus->synchronyConfigurationSupported.byte);
+}
+
+TEST_F(EventManagerTest, pollForPlatformEventTaskMultipartTransferTest)
+{
+    // Add terminus
+    auto mappedTid = terminusManager.mapTid(pldm::MctpInfo(1, "", "", 1));
+    auto tid = mappedTid.value();
+    termini[tid] =
+        std::make_shared<Terminus>(tid, 1 << PLDM_BASE | 1 << PLDM_PLATFORM);
+    auto terminus = termini[tid];
+
+    // queue pollForPlatformEventMessage first part response
+    const size_t pollForPlatformEventMessage1Len = 22;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + pollForPlatformEventMessage1Len>
+        pollForPlatformEventMessage1Resp{
+            0x0,        0x02, 0x0d, PLDM_SUCCESS,
+            tid,                         // TID
+            0x1,        0x0,             // eventID
+            0x1,        0x0,  0x0,  0x0, // nextDataTransferHandle
+            PLDM_START,                  // transferFlag = start
+            0xfa,                        // eventClass
+            8,          0,    0,    0,   // eventDataSize
+            0x01,                        // CPER event formatVersion= 0x01
+            1,                        // formatType = single CPER section(0x01)
+            10,         0,            // eventDataLength = 10
+            1,          2,    3,    4 // eventData first part
+        };
+    auto rc = terminusManager.enqueueResponse(
+        (pldm_msg*)pollForPlatformEventMessage1Resp.data(),
+        sizeof(pollForPlatformEventMessage1Resp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    // queue pollForPlatformEventMessage last part response
+    const size_t pollForPlatformEventMessage2Len = 24;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + pollForPlatformEventMessage2Len>
+        pollForPlatformEventMessage2Resp{
+            0x0,      0x02, 0x0d, PLDM_SUCCESS,
+            tid,                       // TID
+            0x1,      0x0,             // eventID
+            0x2,      0x0,  0x0,  0x0, // nextDataTransferHandle
+            PLDM_END,                  // transferFlag = end
+            0xfa,                      // eventClass
+            6,        0,    0,    0,   // eventDataSize
+            5,        6,    7,    8,
+            9,        0,               // eventData last part
+            0x46,     0x7f, 0x6a, 0x5d // crc32
+        };
+    rc = terminusManager.enqueueResponse(
+        (pldm_msg*)pollForPlatformEventMessage2Resp.data(),
+        sizeof(pollForPlatformEventMessage2Resp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    // queue pollForPlatformEventMessage Ack response
+    const size_t pollForPlatformEventMessage3Len = 4;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + pollForPlatformEventMessage3Len>
+        pollForPlatformEventMessage3Resp{
+            0x0, 0x02, 0x0d, PLDM_SUCCESS,
+            tid,     // TID
+            0x0, 0x0 // eventID
+        };
+    rc = terminusManager.enqueueResponse(
+        (pldm_msg*)pollForPlatformEventMessage3Resp.data(),
+        sizeof(pollForPlatformEventMessage3Resp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    EXPECT_CALL(eventManager, processCperEvent(_, _))
+        .Times(1)
+        .WillRepeatedly(Return(1));
+
+    // start task to poll event from terminus
+    eventManager.pollForPlatformEventTask(tid);
+}
diff --git a/platform-mc/test/meson.build b/platform-mc/test/meson.build
index ae23397..abf990d 100644
--- a/platform-mc/test/meson.build
+++ b/platform-mc/test/meson.build
@@ -5,6 +5,7 @@ test_src = declare_dependency(
             '../platform_manager.cpp',
             '../sensor_manager.cpp',
             '../numeric_sensor.cpp',
+            '../event_manager.cpp',
             '../../requester/mctp_endpoint_discovery.cpp'],
             include_directories: ['../../requester', '../../pldmd'])
 
@@ -14,6 +15,7 @@ tests = [
   'platform_manager_test',
   'sensor_manager_test',
   'numeric_sensor_test',
+  'event_manager_test',
 ]
 
 foreach t : tests
diff --git a/platform-mc/test/mock_event_manager.hpp b/platform-mc/test/mock_event_manager.hpp
new file mode 100644
index 0000000..1ef68a2
--- /dev/null
+++ b/platform-mc/test/mock_event_manager.hpp
@@ -0,0 +1,29 @@
+#pragma once
+
+#include "platform-mc/event_manager.hpp"
+
+#include <gmock/gmock.h>
+
+namespace pldm
+{
+namespace platform_mc
+{
+
+class MockEventManager : public EventManager
+{
+  public:
+    MockEventManager(TerminusManager& terminusManager,
+                     std::map<mctp_eid_t, std::shared_ptr<Terminus>>& termini) :
+        EventManager(terminusManager, termini){};
+
+    MOCK_METHOD(int, createSensorThresholdLogEntry,
+                (const std::string& messageID, const std::string& sensorName,
+                 const double reading, const double threshold),
+                (override));
+
+    MOCK_METHOD(int, processCperEvent,
+                (const uint8_t* eventData, size_t eventDataSize), (override));
+};
+
+} // namespace platform_mc
+} // namespace pldm
diff --git a/platform-mc/test/mock_sensor_manager.hpp b/platform-mc/test/mock_sensor_manager.hpp
index 5cb76f0..db3b1eb 100644
--- a/platform-mc/test/mock_sensor_manager.hpp
+++ b/platform-mc/test/mock_sensor_manager.hpp
@@ -14,8 +14,9 @@ class MockSensorManager : public SensorManager
   public:
     MockSensorManager(sdeventplus::Event& event,
                       TerminusManager& terminusManager,
-                      std::map<tid_t, std::shared_ptr<Terminus>>& termini) :
-        SensorManager(event, terminusManager, termini){};
+                      std::map<mctp_eid_t, std::shared_ptr<Terminus>>& termini,
+                      Manager* manager) :
+        SensorManager(event, terminusManager, termini, manager){};
 
     MOCK_METHOD(void, doSensorPolling, (tid_t tid), (override));
 };
diff --git a/platform-mc/test/mock_terminus_manager.hpp b/platform-mc/test/mock_terminus_manager.hpp
index 1f65eef..917f724 100644
--- a/platform-mc/test/mock_terminus_manager.hpp
+++ b/platform-mc/test/mock_terminus_manager.hpp
@@ -19,7 +19,8 @@ class MockTerminusManager : public TerminusManager
                         pldm::InstanceIdDb& instanceIdDb,
                         std::map<tid_t, std::shared_ptr<Terminus>>& termini,
                         Manager* manager) :
-        TerminusManager(event, handler, instanceIdDb, termini, manager)
+        TerminusManager(event, handler, instanceIdDb, termini, LOCAL_EID,
+                        manager)
     {}
 
     requester::Coroutine SendRecvPldmMsgOverMctp(mctp_eid_t /*eid*/,
diff --git a/platform-mc/test/platform_manager_test.cpp b/platform-mc/test/platform_manager_test.cpp
index 6dbfa0c..eed03a2 100644
--- a/platform-mc/test/platform_manager_test.cpp
+++ b/platform-mc/test/platform_manager_test.cpp
@@ -41,6 +41,25 @@ TEST_F(PlatformManagerTest, initTerminusTest)
         std::make_shared<Terminus>(tid, 1 << PLDM_BASE | 1 << PLDM_PLATFORM);
     auto terminus = termini[tid];
 
+    // queue dummy eventMessageBufferSize response
+    const size_t eventMessageBufferSizeRespLen = 1;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + eventMessageBufferSizeRespLen>
+        eventMessageBufferSizeResp{0x0, 0x02, 0x0d, PLDM_ERROR};
+    auto rc = mockTerminusManager.enqueueResponse(
+        (pldm_msg*)eventMessageBufferSizeResp.data(),
+        sizeof(eventMessageBufferSizeResp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    // queue dummy eventMessageSupported response
+    const size_t eventMessageSupportedLen = 1;
+    PLDM_GET_PDR_REPOSITORY_INFO_RESP_BYTES;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + eventMessageSupportedLen>
+        eventMessageSupportedResp{0x0, 0x02, 0x0c, PLDM_ERROR};
+    rc = mockTerminusManager.enqueueResponse(
+        (pldm_msg*)eventMessageSupportedResp.data(),
+        sizeof(eventMessageSupportedResp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
     // queue getPDRRepositoryInfo response
     const size_t getPDRRepositoryInfoLen =
         PLDM_GET_PDR_REPOSITORY_INFO_RESP_BYTES;
@@ -57,7 +76,7 @@ TEST_F(PlatformManagerTest, initTerminusTest)
             59,  0x0,  0x0,  0x0,                    // largestRecordSize
             0x0 // dataTransferHandleTimeout
         };
-    auto rc = mockTerminusManager.enqueueResponse(
+    rc = mockTerminusManager.enqueueResponse(
         (pldm_msg*)getPDRRepositoryInfoResp.data(),
         sizeof(getPDRRepositoryInfoResp));
     EXPECT_EQ(rc, PLDM_SUCCESS);
diff --git a/platform-mc/test/sensor_manager_test.cpp b/platform-mc/test/sensor_manager_test.cpp
index 56e1d36..2dc606b 100644
--- a/platform-mc/test/sensor_manager_test.cpp
+++ b/platform-mc/test/sensor_manager_test.cpp
@@ -21,8 +21,8 @@ class SensorManagerTest : public testing::Test
         bus(pldm::utils::DBusHandler::getBus()),
         event(sdeventplus::Event::get_default()), instanceIdDb(),
         reqHandler(pldmTransport, event, instanceIdDb, false),
-        terminusManager(event, reqHandler, instanceIdDb, termini, nullptr),
-        sensorManager(event, terminusManager, termini)
+        terminusManager(event, reqHandler, instanceIdDb, termini, 0x0, nullptr),
+        sensorManager(event, terminusManager, termini, nullptr)
     {}
 
     void runEventLoopForSeconds(uint64_t sec)
diff --git a/platform-mc/test/terminus_manager_test.cpp b/platform-mc/test/terminus_manager_test.cpp
index b77a197..2fb3f1e 100644
--- a/platform-mc/test/terminus_manager_test.cpp
+++ b/platform-mc/test/terminus_manager_test.cpp
@@ -31,7 +31,7 @@ class TerminusManagerTest : public testing::Test
         event(sdeventplus::Event::get_default()), instanceIdDb(),
         reqHandler(pldmTransport, event, instanceIdDb, false, seconds(1), 2,
                    milliseconds(100)),
-        terminusManager(event, reqHandler, instanceIdDb, termini, nullptr),
+        terminusManager(event, reqHandler, instanceIdDb, termini, 0x0, nullptr),
         mockTerminusManager(event, reqHandler, instanceIdDb, termini, nullptr)
     {}
 
diff --git a/pldmd/pldmd.cpp b/pldmd/pldmd.cpp
index 401ca01..78289c7 100644
--- a/pldmd/pldmd.cpp
+++ b/pldmd/pldmd.cpp
@@ -272,11 +272,38 @@ int main(int argc, char** argv)
     // FRU table is built lazily when a FRU command or Get PDR command is
     // handled. To enable building FRU table, the FRU handler is passed to the
     // Platform handler.
+
+    std::unique_ptr<platform_mc::Manager> platformManager =
+        std::make_unique<platform_mc::Manager>(event, reqHandler, instanceIdDb);
+
+    pldm::responder::platform::EventMap addOnEventHandlers{
+        {PLDM_OEM_EVENT_CLASS_0xFA,
+         {[&platformManager](const pldm_msg* request, size_t payloadLength,
+                             uint8_t formatVersion, uint8_t tid,
+                             size_t eventDataOffset) {
+        return platformManager->handleCperEvent(
+            request, payloadLength, formatVersion, tid, eventDataOffset);
+    }}},
+        {PLDM_MESSAGE_POLL_EVENT,
+         {[&platformManager](const pldm_msg* request, size_t payloadLength,
+                             uint8_t formatVersion, uint8_t tid,
+                             size_t eventDataOffset) {
+        return platformManager->handlePldmMessagePollEvent(
+            request, payloadLength, formatVersion, tid, eventDataOffset);
+    }}},
+        {PLDM_SENSOR_EVENT,
+         {[&platformManager](const pldm_msg* request, size_t payloadLength,
+                             uint8_t formatVersion, uint8_t tid,
+                             size_t eventDataOffset) {
+        return platformManager->handleSensorEvent(
+            request, payloadLength, formatVersion, tid, eventDataOffset);
+    }}}};
+
     auto platformHandler = std::make_unique<platform::Handler>(
         &dbusHandler, hostEID, &instanceIdDb, PDR_JSONS_DIR, pdrRepo.get(),
         hostPDRHandler.get(), dbusToPLDMEventHandler.get(), fruHandler.get(),
         oemPlatformHandler.get(), platformConfigHandler.get(), &reqHandler,
-        event, true);
+        event, true, addOnEventHandlers);
 #ifdef OEM_IBM
     pldm::responder::oem_ibm_platform::Handler* oemIbmPlatformHandler =
         dynamic_cast<pldm::responder::oem_ibm_platform::Handler*>(
@@ -302,8 +329,6 @@ int main(int argc, char** argv)
 
     std::unique_ptr<fw_update::Manager> fwManager =
         std::make_unique<fw_update::Manager>(event, reqHandler, instanceIdDb);
-    std::unique_ptr<platform_mc::Manager> platformManager =
-        std::make_unique<platform_mc::Manager>(event, reqHandler, instanceIdDb);
     std::unique_ptr<MctpDiscovery> mctpDiscoveryHandler =
         std::make_unique<MctpDiscovery>(
             bus, std::initializer_list<MctpDiscoveryHandlerIntf*>{
-- 
2.25.1

