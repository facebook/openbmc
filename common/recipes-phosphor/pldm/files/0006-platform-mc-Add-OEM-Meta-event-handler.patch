From d4c3f7b5aacca632bb872ed631b50327c4446197 Mon Sep 17 00:00:00 2001
From: Delphine CC Chiu <Delphine_CC_Chiu@wiwynn.com>
Date: Wed, 7 Feb 2024 13:52:07 +0800
Subject: [PATCH 06/12] platform-mc: Add OEM Meta event handler

Add OEM Meta handler with event type 0xFB. It will print the logs
with prefix "BIOS_IPMI_SEL", so the user can utilize it to filter
the journal logs. It will also send logs on D-Bus.

Tested: tested and verified on yosemite4 system.
Test Log:
root@bmc:~# journalctl |grep BIOS_IPMI_SEL
Feb 07 07:14:34 bmc pldmd[897]: BIOS_IPMI_SEL: Host 4: GeneralInfo:
 MEMORY_ECC_ERR(0x21), DIMM Slot Location: Sled 0/Socket 0, Channel
 0, Slot 0, DIMM A0, DIMM Failure Event: Memory correctable error

```
root@bmc:~# busctl introspect xyz.openbmc_project.Logging  /xyz/openbmc_project/logging/entry/3 -l
NAME                                        TYPE      SIGNATURE RESULT/VALUE                                                                                                                                                                                  FLAGS
org.freedesktop.DBus.Introspectable         interface -         -                                                                                                                                                                                             -
.Introspect                                 method    -         s                                                                                                                                                                                             -
org.freedesktop.DBus.Peer                   interface -         -                                                                                                                                                                                             -
.GetMachineId                               method    -         s                                                                                                                                                                                             -
.Ping                                       method    -         -                                                                                                                                                                                             -
org.freedesktop.DBus.Properties             interface -         -                                                                                                                                                                                             -
.Get                                        method    ss        v                                                                                                                                                                                             -
.GetAll                                     method    s         a{sv}                                                                                                                                                                                         -
.Set                                        method    ssv       -                                                                                                                                                                                             -
.PropertiesChanged                          signal    sa{sv}as  -                                                                                                                                                                                             -
xyz.openbmc_project.Association.Definitions interface -         -                                                                                                                                                                                             -
.Associations                               property  a(sss)    0                                                                                                                                                                                             emits-change writable
xyz.openbmc_project.Common.FilePath         interface -         -                                                                                                                                                                                             -
.Path                                       property  s         "/var/lib/phosphor-logging/errors/3"                                                                                                                                                          emits-change writable
xyz.openbmc_project.Logging.Entry           interface -         -                                                                                                                                                                                             -
.GetEntry                                   method    -         h                                                                                                                                                                                             -
.AdditionalData                             property  as        0                                                                                                                                                                                             emits-change writable
.EventId                                    property  s         ""                                                                                                                                                                                            emits-change writable
.Id                                         property  u         3                                                                                                                                                                                             emits-change writable
.Message                                    property  s         "BIOS_IPMI_SEL: Host 4: GeneralInfo: MEMORY_ECC_ERR(0x21), DIMM Slot Location: Sled 0/Socket 0, Channel 0, Slot 0, DIMM A0, DIMM Failure Event: Memory correctable error" emits-change writable
.Resolution                                 property  s         ""                                                                                                                                                                                            emits-change writable
.Resolved                                   property  b         false                                                                                                                                                                                         emits-change writable
.ServiceProviderNotify                      property  s         "xyz.openbmc_project.Logging.Entry.Notify.NotSupported"                                                                                                                                       emits-change writable
.Severity                                   property  s         "xyz.openbmc_project.Logging.Entry.Level.Error"                                                                                                                                               emits-change writable
.Timestamp                                  property  t         1706147743858                                                                                                                                                                                 emits-change writable
.UpdateTimestamp                            property  t         1706147743858                                                                                                                                                                                 emits-change writable
xyz.openbmc_project.Object.Delete           interface -         -                                                                                                                                                                                             -
.Delete                                     method    -         -                                                                                                                                                                                             -
xyz.openbmc_project.Software.Version        interface -         -                                                                                                                                                                                             -
.Purpose                                    property  s         "xyz.openbmc_project.Software.Version.VersionPurpose.BMC"                                                                                                                                     emits-change writable
.Version                                    property  s         "yosemite4-b23efa40c0f-dirty"                                                                                                                                                                 emits-change writable

```

Change-Id: I722d8e09e7aea8dfa533e921d41beb505b59fb95
Signed-off-by: Delphine CC Chiu <Delphine_CC_Chiu@wiwynn.com>
---
 meson.build                             |   1 +
 oem/meta/platform-mc/event_oem_meta.cpp | 815 ++++++++++++++++++++++++
 oem/meta/platform-mc/event_oem_meta.hpp |  21 +
 platform-mc/event_manager.cpp           |  33 +
 platform-mc/event_manager.hpp           |  13 +-
 platform-mc/manager.hpp                 |  26 +-
 platform-mc/test/meson.build            |   2 +
 pldmd/pldmd.cpp                         |  10 +-
 8 files changed, 915 insertions(+), 6 deletions(-)
 create mode 100644 oem/meta/platform-mc/event_oem_meta.cpp
 create mode 100644 oem/meta/platform-mc/event_oem_meta.hpp

diff --git a/meson.build b/meson.build
index e9177e6..e849a9b 100644
--- a/meson.build
+++ b/meson.build
@@ -253,6 +253,7 @@ executable(
     'platform-mc/event_manager.cpp',
     'requester/mctp_endpoint_discovery.cpp',
     'requester/configuration_discovery_handler.cpp',
+    'oem/meta/platform-mc/event_oem_meta.cpp',
     implicit_include_directories: false,
     dependencies: deps,
     install: true,
diff --git a/oem/meta/platform-mc/event_oem_meta.cpp b/oem/meta/platform-mc/event_oem_meta.cpp
new file mode 100644
index 0000000..a4575bc
--- /dev/null
+++ b/oem/meta/platform-mc/event_oem_meta.cpp
@@ -0,0 +1,815 @@
+#include "event_oem_meta.hpp"
+
+#include "common/utils.hpp"
+
+#include <phosphor-logging/lg2.hpp>
+#include <xyz/openbmc_project/Inventory/Decorator/Slot/client.hpp>
+
+#include <cstdint>
+#include <iostream>
+#include <sstream>
+
+namespace pldm
+{
+namespace platform_mc
+{
+namespace oem_meta
+{
+
+typedef struct _dimm_info
+{
+    uint8_t sled;
+    uint8_t socket;
+    uint8_t channel;
+    uint8_t slot;
+} _dimm_info;
+
+constexpr auto slotNumberProperty = "SlotNumber";
+using DecoratorSlot =
+    sdbusplus::client::xyz::openbmc_project::inventory::decorator::Slot<>;
+
+void covertToDimmString(uint8_t cpu, uint8_t channel, uint8_t slot,
+                        std::string& str)
+{
+    constexpr char label[] = {'A', 'C', 'B', 'D'};
+    constexpr size_t labelSize = sizeof(label);
+
+    size_t idx = cpu * 2 + slot;
+    if (idx < labelSize)
+    {
+        str = label[idx] + std::to_string(channel);
+    }
+    else
+    {
+        str = "NA";
+    }
+}
+
+void getCommonDimmLocation(const _dimm_info& dimmInfo,
+                           std::string& dimmLocation, std::string& dimm)
+{
+    std::string sled_str = std::to_string(dimmInfo.sled);
+    std::string socket_str = std::to_string(dimmInfo.socket);
+
+    // Check Channel and Slot
+    if (dimmInfo.channel == 0xFF && dimmInfo.slot == 0xFF)
+    {
+        dimm = "unknown";
+        dimmLocation = "DIMM Slot Location: Sled " + sled_str + "/Socket " +
+                       socket_str +
+                       ", Channel unknown, Slot unknown, DIMM unknown";
+    }
+    else
+    {
+        uint8_t channel = dimmInfo.channel & 0x0F;
+        uint8_t slot = dimmInfo.slot & 0x07;
+        covertToDimmString(dimmInfo.socket, channel, slot, dimm);
+
+        std::string channel_str = std::to_string(channel);
+        std::string slot_str = std::to_string(slot);
+
+        dimmLocation = "DIMM Slot Location: Sled " + sled_str + "/Socket " +
+                       socket_str + ", Channel " + channel_str + ", Slot " +
+                       slot_str + ", DIMM " + dimm;
+    }
+}
+
+static inline auto to_hex_string(uint8_t value)
+{
+    return std::format("{:02x}", value);
+}
+
+std::string getSlotNumberString(
+    pldm_tid_t tid, const std::map<std::string, MctpEndpoint>& configurations)
+{
+    std::string slotNumber = "Unknown";
+    for (const auto& [configDbusPath, mctpEndpoint] : configurations)
+    {
+        if (mctpEndpoint.EndpointId == tid)
+        {
+            std::string endpointDbusPath;
+            try
+            {
+                auto response = pldm::utils::DBusHandler().getAncestors(
+                    configDbusPath.c_str(), {DecoratorSlot::interface});
+                if (response.size() != 1)
+                {
+                    lg2::error(
+                        "Only Board layer should have Decorator.Slot interface, got {SIZE} Dbus Object(s) have interface Decorator.Slot}",
+                        "SIZE", response.size());
+                    return slotNumber; // return "Unknown"
+                }
+                endpointDbusPath = std::get<0>(response.front());
+            }
+            catch (const sdbusplus::exception_t& e)
+            {
+                lg2::error("{FUNC}: Failed to call GetAncestors, ERROR={ERROR}",
+                           "FUNC", std::string(__func__), "ERROR", e.what());
+                return slotNumber; // return "Unknown";
+            }
+
+            try
+            {
+                auto number =
+                    pldm::utils::DBusHandler().getDbusProperty<uint64_t>(
+                        endpointDbusPath.c_str(), slotNumberProperty,
+                        DecoratorSlot::interface);
+                slotNumber = std::to_string(number);
+            }
+            catch (const sdbusplus::exception_t& e)
+            {
+                lg2::error("{FUNC}: Failed to execute Dbus call, ERROR={ERROR}",
+                           "FUNC", std::string(__func__), "ERROR", e.what());
+                return slotNumber; // return "Unknown"
+            }
+        }
+    }
+    return slotNumber;
+}
+
+int processOemMetaEvent(
+    pldm_tid_t tid, const uint8_t* eventData,
+    [[maybe_unused]] size_t eventDataSize,
+    const std::map<std::string, MctpEndpoint>& configurations)
+{
+    enum class RecordType : uint8_t
+    {
+        SYSTEM_EVENT_RECORD = 0x02,
+        UNIFIED_BIOS_SEL = 0xFB,
+    };
+
+    enum class UnifiedError : uint8_t
+    {
+        UNIFIED_PCIE_ERR = 0x0,
+        UNIFIED_MEM_ERR = 0x1,
+        UNIFIED_UPI_ERR = 0x2,
+        UNIFIED_IIO_ERR = 0x3,
+        UNIFIED_MCA_ERR = 0x4,
+        UNIFIED_MCA_ERR_EXT = 0x5,
+        UNIFIED_RP_PIO_1st = 0x6,
+        UNIFIED_RP_PIO_2nd = 0x7,
+        UNIFIED_POST_ERR = 0x8,
+        UNIFIED_PCIE_EVENT = 0x9,
+        UNIFIED_MEM_EVENT = 0xA,
+        UNIFIED_UPI_EVENT = 0xB,
+        UNIFIED_BOOT_GUARD = 0xC,
+        UNIFIED_PPR_EVENT = 0xD,
+        UNIFIED_CXL_MEM_ERR = 0xE,
+    };
+
+    enum class MemoryError : uint8_t
+    {
+        MEMORY_TRAINING_ERR = 0x0,
+        MEMORY_CORRECTABLE_ERR = 0x1,
+        MEMORY_UNCORRECTABLE_ERR = 0x2,
+        MEMORY_CORR_ERR_PTRL_SCR = 0x3,
+        MEMORY_UNCORR_ERR_PTRL_SCR = 0x4,
+        MEMORY_PARITY_ERR_PCC0 = 0x5,
+        MEMORY_PARITY_ERR_PCC1 = 0x6,
+        MEMORY_PMIC_ERR = 0x7,
+    };
+
+    enum class PostError : uint8_t
+    {
+        POST_PXE_BOOT_FAIL = 0x0,
+        POST_CMOS_CLEARED = 0x1,
+        POST_TPM_SELF_TEST_FAIL = 0x2,
+        POST_BOOT_DRIVE_FAIL = 0x3,
+        POST_DATA_DRIVE_FAIL = 0x4,
+        POST_INVALID_BOOT_ORDER = 0x5,
+        POST_HTTP_BOOT_FAIL = 0x6,
+        POST_GET_CERT_FAIL = 0x7,
+        POST_AMD_ABL_FAIL = 0xA,
+    };
+
+    enum class PcieEvent : uint8_t
+    {
+        PCIE_DPC = 0x0,
+    };
+
+    enum MemoryEvent : uint8_t
+    {
+        MEM_PPR = 0x0,
+        MEM_ADDDC = 0x5,
+        MEM_NO_DIMM = 0x7,
+    };
+
+    enum class UpiError : uint8_t
+    {
+        UPI_INIT_ERR = 0x0,
+    };
+
+    static constexpr auto errorSeverityDetail = std::to_array(
+        {"Correctable Error", "Deferred Error", "Uncorrected Recoverable Error",
+         "Uncorrected Thread Fatal Error", "Uncorrected System Fatal Error"});
+
+    static constexpr auto machineCheckBank = std::to_array(
+        {"LS",
+         "IF",
+         "L2",
+         "DE",
+         "RAZ",
+         "EX",
+         "FP",
+         "L3",
+         "L3",
+         "L3",
+         "L3",
+         "L3",
+         "L3",
+         "L3",
+         "L3",
+         "MP5",
+         "PB",
+         "PCS_GMI",
+         "PCS_GMI",
+         "KPX_GMI",
+         "KPX_GMI",
+         "UMC/PB/RAZ",
+         "UMC/PCIE/RAZ",
+         "CS/RAZ",
+         "CS/RAZ",
+         "NBIO/SHUB/RAZ",
+         "PCIE/SATA/RAZ",
+         "PCIE/NBIF/RAZ",
+         "PIE/PSP/KPX_WALF/NBIF/USB/RAZ",
+         "SMU/MPDMA/RAZ",
+         "PCS_XGMI/RAZ",
+         "KPX_SERDES/RAZ"});
+
+    static constexpr auto memoryError = std::to_array(
+        {"Memory training failure", "Memory correctable error",
+         "Memory uncorrectable error",
+         "Memory correctable error (Patrol scrub)",
+         "Memory uncorrectable error (Patrol scrub)",
+         "Memory Parity Error (PCC=0)", "Memory Parity Error (PCC=1)",
+         "Memory PMIC Error", "CXL Memory training error", "Reserved"});
+
+    static constexpr auto certEvent =
+        std::to_array({"No certificate at BMC", "IPMI transaction fail",
+                       "Certificate data corrupted", "Reserved"});
+
+    static constexpr auto postError = std::to_array(
+        {"System PXE boot fail", "CMOS/NVRAM configuration cleared",
+         "TPM Self-Test Fail", "Boot Drive failure", "Data Drive failure",
+         "Received invalid boot order request from BMC",
+         "System HTTP boot fail", "BIOS fails to get the certificate from BMC",
+         "Password cleared by jumper", "DXE FV check failure",
+         "AMD ABL failure", "Reserved"});
+
+    static constexpr auto pcieEvent = std::to_array(
+        {"PCIe DPC Event", "PCIe LER Event",
+         "PCIe Link Retraining and Recovery",
+         "PCIe Link CRC Error Check and Retry", "PCIe Corrupt Data Containment",
+         "PCIe Express ECRC", "Reserved"});
+
+    static constexpr auto memoryEvent = std::to_array(
+        {"Memory PPR event", "Memory Correctable Error logging limit reached",
+         "Memory disable/map-out for FRB", "Memory SDDC",
+         "Memory Address range/Partial mirroring", "Memory ADDDC",
+         "Memory SMBus hang recovery", "No DIMM in System", "Reserved"});
+
+    static constexpr auto memoryPprRepairTime =
+        std::to_array({"Boot time", "Autonomous", "Run time", "Reserved"});
+
+    static constexpr auto memoryPprEvent =
+        std::to_array({"PPR success", "PPR fail", "PPR request", "Reserved"});
+
+    static constexpr auto memoryAdddcEvent = std::to_array(
+        {"Bank VLS", "r-Bank VLS + re-buddy", "r-Bank VLS + Rank VLS",
+         "r-Rank VLS + re-buddy"});
+
+    static constexpr auto upiEvent = std::to_array(
+        {"Successful LLR without Phy Reinit", "Successful LLR with Phy Reinit",
+         "COR Phy Lane failure, recovery in x8 width", "Reserved"});
+
+    static constexpr auto pprEvent =
+        std::to_array({"PPR disable", "Soft PPR", "Hard PPR"});
+
+    static constexpr auto upiError =
+        std::to_array({"UPI Init error", "Reserved"});
+
+    RecordType recordType = static_cast<RecordType>(eventData[0]);
+    uint8_t generalInfo = eventData[1];
+    std::cerr << "eventData[0]  = " << eventData[0];
+    UnifiedError errorType = static_cast<UnifiedError>(generalInfo & 0xF);
+    _dimm_info dimmInfo = {
+        static_cast<uint8_t>((eventData[6] >> 4) & 0x03), // Sled
+        static_cast<uint8_t>(eventData[6] & 0x0F),        // Socket
+        static_cast<uint8_t>(eventData[7]),               // Channel
+        static_cast<uint8_t>(eventData[8])                // Slot
+    };
+    std::string errorLog;
+    switch (recordType)
+    {
+        case RecordType::SYSTEM_EVENT_RECORD:
+        {
+            // Currently, we only have one standard SEL needed to support on
+            // YV4.
+            if (eventData[9] == 0x2B)
+            {
+                errorLog = "POST_ERROR:";
+                if ((eventData[11] & 0x0F) == 0x0)
+                    errorLog += ", System Firmware Error";
+
+                if (((eventData[11] >> 6) & 0x03) == 0x2)
+                {
+                    errorLog += ", OEM Post Code 0x" +
+                                to_hex_string(eventData[13]) +
+                                to_hex_string(eventData[12]);
+                }
+
+                switch ((eventData[13] << 8) | eventData[12])
+                {
+                    case 0xD9:
+                        errorLog +=
+                            ", Error loading Boot Option (Load image returned error)";
+                        break;
+                    default:
+                        break;
+                }
+            }
+            else
+            { // Not supported
+                errorLog =
+                    "Record Type(0x" +
+                    to_hex_string(static_cast<uint8_t>(recordType)) +
+                    "), Raw: " + to_hex_string(eventData[1]) +
+                    to_hex_string(eventData[2]) + to_hex_string(eventData[3]) +
+                    to_hex_string(eventData[4]) + to_hex_string(eventData[5]) +
+                    to_hex_string(eventData[6]) + to_hex_string(eventData[7]) +
+                    to_hex_string(eventData[8]) + to_hex_string(eventData[9]) +
+                    to_hex_string(eventData[10]) +
+                    to_hex_string(eventData[11]) +
+                    to_hex_string(eventData[12]) + to_hex_string(eventData[13]);
+            }
+            break;
+        }
+        case RecordType::UNIFIED_BIOS_SEL:
+        {
+            switch (errorType)
+            {
+                case UnifiedError::UNIFIED_PCIE_ERR:
+                {
+                    uint8_t plat = (generalInfo & 0x10) >> 4;
+                    if (plat == 0)
+                    { // x86
+                        errorLog =
+                            "GeneralInfo: x86/PCIeErr(0x" +
+                            to_hex_string(generalInfo) + "), Bus " +
+                            to_hex_string(eventData[9]) + "/Dev " +
+                            to_hex_string(eventData[8] >> 3) + "/Fun " +
+                            to_hex_string(eventData[8] & 0x7) + ", ErrID2: 0x" +
+                            to_hex_string(eventData[12]) + ", ErrID1: 0x" +
+                            to_hex_string(eventData[13]);
+                    }
+                    else
+                    {
+                        errorLog =
+                            "GeneralInfo: ARM/PCIeErr(0x" +
+                            to_hex_string(generalInfo) + "), Aux. Info: 0x" +
+                            to_hex_string((eventData[7] << 8) | eventData[6]) +
+                            ", Bus " + to_hex_string(eventData[9]) + "/Dev " +
+                            to_hex_string(eventData[8] >> 3) + "/Fun " +
+                            to_hex_string(eventData[8] & 0x7) + ", ErrID2: 0x" +
+                            to_hex_string(eventData[12]) + ", ErrID1: 0x" +
+                            to_hex_string(eventData[13]);
+                    }
+                    break;
+                }
+                case UnifiedError::UNIFIED_MEM_ERR:
+                {
+                    std::string dimmLocation, dimm;
+                    getCommonDimmLocation(dimmInfo, dimmLocation, dimm);
+                    uint8_t plat = (eventData[10] & 0x80) >> 7;
+                    MemoryError eventType =
+                        static_cast<MemoryError>(eventData[10] & 0xF);
+                    switch (eventType)
+                    {
+                        case MemoryError::MEMORY_TRAINING_ERR:
+                        case MemoryError::MEMORY_PMIC_ERR:
+                        {
+                            if (plat == 0)
+                            { // Intel
+                                errorLog =
+                                    "GeneralInfo: MEMORY_ECC_ERR(0x" +
+                                    to_hex_string(generalInfo) + "), " +
+                                    dimmLocation + ", DIMM Failure Event: " +
+                                    memoryError[static_cast<uint8_t>(
+                                        eventType)] +
+                                    ", Major Code: 0x" +
+                                    to_hex_string(eventData[11]) +
+                                    ", Minor Code: 0x" +
+                                    to_hex_string(eventData[12]);
+                            }
+                            else
+                            { // AMD
+                                errorLog =
+                                    "GeneralInfo: MEMORY_ECC_ERR(0x" +
+                                    to_hex_string(generalInfo) + "), " +
+                                    dimmLocation + ", DIMM Failure Event: " +
+                                    memoryError[static_cast<uint8_t>(
+                                        eventType)] +
+                                    ", Major Code: 0x" +
+                                    to_hex_string(eventData[11]) +
+                                    ", Minor Code: 0x" +
+                                    to_hex_string((eventData[13] << 8) |
+                                                  eventData[12]);
+                            }
+                            break;
+                        }
+                        default:
+                            covertToDimmString(dimmInfo.socket,
+                                               dimmInfo.channel, dimmInfo.slot,
+                                               dimm);
+                            uint8_t estrIdx =
+                                (static_cast<uint8_t>(eventType) <
+                                 memoryError.size())
+                                    ? static_cast<uint8_t>(eventType)
+                                    : (memoryError.size() - 1);
+                            errorLog = "GeneralInfo: MEMORY_ECC_ERR(0x" +
+                                       to_hex_string(generalInfo) + "), " +
+                                       dimmLocation + ", DIMM Failure Event: " +
+                                       memoryError[estrIdx];
+                            break;
+                    }
+                    break;
+                }
+                case UnifiedError::UNIFIED_UPI_ERR:
+                {
+                    UpiError eventType =
+                        static_cast<UpiError>(eventData[10] & 0xF);
+                    uint8_t estrIdx =
+                        (static_cast<uint8_t>(eventType) < upiError.size())
+                            ? static_cast<uint8_t>(eventType)
+                            : (upiError.size() - 1);
+
+                    switch (eventType)
+                    {
+                        case UpiError::UPI_INIT_ERR:
+                        {
+                            errorLog =
+                                "GeneralInfo: UPIErr(0x" +
+                                to_hex_string(generalInfo) +
+                                "), UPI Port Location: Sled " +
+                                std::to_string(dimmInfo.sled) + "/Socket " +
+                                std::to_string(dimmInfo.socket) + ", Port " +
+                                std::to_string(eventData[4] & 0xF) +
+                                ", UPI Failure Event: " + upiError[estrIdx] +
+                                ", Major Code: 0x" +
+                                to_hex_string(eventData[8]) +
+                                ", Minor Code: 0x" +
+                                to_hex_string(eventData[9]);
+                            break;
+                        }
+                        default:
+                        {
+                            errorLog =
+                                "GeneralInfo: UPIErr(0x" +
+                                to_hex_string(generalInfo) +
+                                "), UPI Port Location: Sled " +
+                                std::to_string(dimmInfo.sled) + "/Socket " +
+                                std::to_string(dimmInfo.socket) + ", Port " +
+                                std::to_string(eventData[4] & 0xF) +
+                                ", UPI Failure Event: " + upiError[estrIdx];
+                            break;
+                        }
+                    }
+                    break;
+                }
+                case UnifiedError::UNIFIED_IIO_ERR:
+                {
+                    uint8_t stack = eventData[7];
+                    uint8_t selErrorType = eventData[11];
+                    uint8_t selErrorSeverity = eventData[12];
+                    uint8_t selErrorId = eventData[13];
+
+                    errorLog =
+                        "GeneralInfo: IIOErr(0x" + to_hex_string(generalInfo) +
+                        "), IIO Port Location: Sled " +
+                        std::to_string(dimmInfo.sled) + "/Socket " +
+                        std::to_string(dimmInfo.socket) + ", Stack 0x" +
+                        to_hex_string(stack) + ", Error Type: 0x" +
+                        to_hex_string(selErrorType) + ", Error Severity: 0x" +
+                        to_hex_string(selErrorSeverity) + ", Error ID: 0x" +
+                        to_hex_string(selErrorId);
+                    break;
+                }
+                case UnifiedError::UNIFIED_MCA_ERR:
+                {
+                    uint8_t mcaSeverity = ((eventData[6] >> 4) & 0x07);
+                    uint8_t cpuNumber = (eventData[7] >> 5) & 0x07;
+                    uint8_t coreNumber = eventData[7] & 0x1F;
+                    uint8_t machineCheckBankNumber = eventData[8];
+                    uint32_t errorInfo =
+                        (static_cast<uint32_t>(eventData[9]) << 16) |
+                        (static_cast<uint32_t>(eventData[10]) << 8) |
+                        static_cast<uint32_t>(eventData[11]);
+                    uint8_t errorCode = eventData[12];
+                    uint8_t errorStatus = eventData[13];
+
+                    errorLog =
+                        "GeneralInfo: MCAErr(0x" + to_hex_string(generalInfo) +
+                        "), MCA Severity: " + errorSeverityDetail[mcaSeverity] +
+                        ", CPU Number: " + std::to_string(cpuNumber) +
+                        ", Core Number: " + std::to_string(coreNumber) +
+                        ", Machine Check Bank: " +
+                        machineCheckBank[machineCheckBankNumber] +
+                        ", Error Info: 0x" + to_hex_string(errorInfo) +
+                        ", Error Code: 0x" + to_hex_string(errorCode) +
+                        ", Error Status: 0x" + to_hex_string(errorStatus);
+                    break;
+                }
+                case UnifiedError::UNIFIED_MCA_ERR_EXT:
+                {
+                    uint8_t mcaSeverity = ((eventData[6] >> 4) & 0x07);
+                    uint8_t cpuNumber = (eventData[7] >> 5) & 0x07;
+                    uint8_t coreNumber = eventData[7] & 0x1F;
+                    uint8_t machineCheckBankNumber = eventData[8];
+                    uint16_t errorCode = (eventData[9] << 8) | eventData[10];
+
+                    errorLog =
+                        "GeneralInfo: MCAErrExt(0x" +
+                        to_hex_string(generalInfo) +
+                        "), MCA Severity: " + errorSeverityDetail[mcaSeverity] +
+                        ", CPU Number: " + std::to_string(cpuNumber) +
+                        ", Core Number: " + std::to_string(coreNumber) +
+                        ", Machine Check Bank: " +
+                        machineCheckBank[machineCheckBankNumber] +
+                        ", Error Code: 0x" + to_hex_string(errorCode);
+                    break;
+                }
+                case UnifiedError::UNIFIED_RP_PIO_1st:
+                case UnifiedError::UNIFIED_RP_PIO_2nd:
+                {
+                    auto offset =
+                        static_cast<uint8_t>(errorType) -
+                        static_cast<uint8_t>(UnifiedError::UNIFIED_RP_PIO_1st);
+                    errorLog =
+                        "GeneralInfo: RP_PIOEvent(0x" +
+                        to_hex_string(generalInfo) + "), RP_PIO Header Log" +
+                        std::to_string(1 + offset * 2) + ": 0x" +
+                        to_hex_string(eventData[9]) +
+                        to_hex_string(eventData[8]) +
+                        to_hex_string(eventData[7]) +
+                        to_hex_string(eventData[6]) + ", RP_PIO Header Log" +
+                        std::to_string(2 + offset * 2) + ": 0x" +
+                        to_hex_string(eventData[13]) +
+                        to_hex_string(eventData[12]) +
+                        to_hex_string(eventData[11]) +
+                        to_hex_string(eventData[10]);
+                    break;
+                }
+                case UnifiedError::UNIFIED_POST_ERR:
+                {
+                    uint8_t certEventIdx = (eventData[10] < certEvent.size())
+                                               ? eventData[10]
+                                               : (certEvent.size() - 1);
+                    uint8_t failType = eventData[11] & 0xF;
+                    uint8_t errCode = eventData[12];
+                    PostError eventType =
+                        static_cast<PostError>(eventData[6] & 0xF);
+                    uint8_t estrIdx =
+                        (static_cast<uint8_t>(eventType) < postError.size())
+                            ? static_cast<uint8_t>(eventType)
+                            : (postError.size() - 1);
+
+                    switch (eventType)
+                    {
+                        case PostError::POST_PXE_BOOT_FAIL:
+                        case PostError::POST_HTTP_BOOT_FAIL:
+                        {
+                            std::string tempLog;
+                            if (failType == 4 || failType == 6)
+                            {
+                                tempLog = "IPv" + std::to_string(failType) +
+                                          " fail";
+                            }
+                            else
+                            {
+                                tempLog = "0x" + to_hex_string(eventData[11]);
+                            }
+                            errorLog =
+                                "GeneralInfo: POST(0x" +
+                                to_hex_string(generalInfo) +
+                                "), POST Failure Event: " + postError[estrIdx] +
+                                ", Fail Type: " + tempLog + ", Error Code: 0x" +
+                                to_hex_string(errCode);
+                            break;
+                        }
+                        case PostError::POST_GET_CERT_FAIL:
+                        {
+                            errorLog =
+                                "GeneralInfo: POST(0x" +
+                                to_hex_string(generalInfo) +
+                                "), POST Failure Event: " + postError[estrIdx] +
+                                ", Failure Detail: " + certEvent[certEventIdx];
+                            break;
+                        }
+                        case PostError::POST_AMD_ABL_FAIL:
+                        {
+                            uint16_t ablErrCode = (eventData[13] << 8) |
+                                                  eventData[12];
+                            errorLog =
+                                "GeneralInfo: POST(0x" +
+                                to_hex_string(generalInfo) +
+                                "), POST Failure Event: " + postError[estrIdx] +
+                                ", ABL Error Code: 0x" +
+                                to_hex_string(ablErrCode);
+                            break;
+                        }
+                        default:
+                        {
+                            errorLog =
+                                "GeneralInfo: POST(0x" +
+                                to_hex_string(generalInfo) +
+                                "), POST Failure Event: " + postError[estrIdx];
+                            break;
+                        }
+                    }
+                    break;
+                }
+                case UnifiedError::UNIFIED_PCIE_EVENT:
+                {
+                    PcieEvent eventType =
+                        static_cast<PcieEvent>(eventData[6] & 0xF);
+                    uint8_t estrIdx =
+                        (static_cast<uint8_t>(eventType) < pcieEvent.size())
+                            ? static_cast<uint8_t>(eventType)
+                            : (pcieEvent.size() - 1);
+                    switch (eventType)
+                    {
+                        case PcieEvent::PCIE_DPC:
+                        {
+                            errorLog =
+                                "GeneralInfo: PCIeEvent(0x" +
+                                to_hex_string(generalInfo) +
+                                "), PCIe Failure Event: " + pcieEvent[estrIdx] +
+                                ", Status: 0x" +
+                                to_hex_string((eventData[9] << 8) |
+                                              eventData[8]) +
+                                ", Source ID: 0x" +
+                                to_hex_string((eventData[11] << 8) |
+                                              eventData[10]);
+                            break;
+                        }
+                        default:
+                        {
+                            errorLog =
+                                "GeneralInfo: PCIeEvent(0x" +
+                                to_hex_string(generalInfo) +
+                                "), PCIe Failure Event: " + pcieEvent[estrIdx];
+                            break;
+                        }
+                    }
+                    break;
+                }
+                case UnifiedError::UNIFIED_MEM_EVENT:
+                {
+                    // get dimm location data string.
+                    std::string dimmLocation, dimm;
+                    getCommonDimmLocation(dimmInfo, dimmLocation, dimm);
+
+                    // Event-Type Bit[3:0]
+                    MemoryEvent eventType =
+                        static_cast<MemoryEvent>(eventData[10] & 0x0F);
+                    switch (eventType)
+                    {
+                        case MemoryEvent::MEM_PPR:
+                        {
+                            errorLog =
+                                "GeneralInfo: MemEvent(0x" +
+                                to_hex_string(generalInfo) + "), " +
+                                dimmLocation + ", DIMM Failure Event: " +
+                                memoryPprRepairTime[eventData[11] >> 2 & 0x03] +
+                                ", " + memoryPprEvent[eventData[11] & 0x03];
+                            break;
+                        }
+                        case MemoryEvent::MEM_ADDDC:
+                        {
+                            uint8_t estrIdx = eventData[12] & 0x03;
+                            if (estrIdx >= memoryAdddcEvent.size())
+                                estrIdx = memoryAdddcEvent.size() - 1;
+                            errorLog =
+                                "GeneralInfo: MemEvent(0x" +
+                                to_hex_string(generalInfo) + "), " +
+                                dimmLocation + ", DIMM Failure Event: " +
+                                memoryEvent[static_cast<uint8_t>(eventType)] +
+                                " " + memoryAdddcEvent[estrIdx];
+                            break;
+                        }
+                        case MemoryEvent::MEM_NO_DIMM:
+                        {
+                            errorLog =
+                                "GeneralInfo: MemEvent(0x" +
+                                to_hex_string(generalInfo) +
+                                "), DIMM Failure Event: " +
+                                memoryEvent[static_cast<uint8_t>(eventType)];
+                            break;
+                        }
+                        default:
+                        {
+                            uint8_t estrIdx =
+                                (static_cast<uint8_t>(eventType) <
+                                 memoryEvent.size())
+                                    ? static_cast<uint8_t>(eventType)
+                                    : (memoryEvent.size() - 1);
+                            errorLog = "GeneralInfo: MemEvent(0x" +
+                                       to_hex_string(generalInfo) + "), " +
+                                       dimmLocation + ", DIMM Failure Event: " +
+                                       memoryEvent[estrIdx];
+                            break;
+                        }
+                    }
+                    break;
+                }
+                case UnifiedError::UNIFIED_UPI_EVENT:
+                {
+                    uint8_t eventType = eventData[10] & 0x0F;
+                    uint8_t estrIdx = (eventType < upiEvent.size())
+                                          ? eventType
+                                          : (upiEvent.size() - 1);
+                    errorLog = "GeneralInfo: UPIEvent(0x" +
+                               to_hex_string(generalInfo) +
+                               "), UPI Port Location: Sled " +
+                               std::to_string(dimmInfo.sled) + "/Socket " +
+                               std::to_string(dimmInfo.socket) + ", Port " +
+                               std::to_string(eventData[7] & 0xF) +
+                               ", UPI Failure Event: " + upiEvent[estrIdx];
+                    break;
+                }
+                case UnifiedError::UNIFIED_BOOT_GUARD:
+                {
+                    errorLog =
+                        "GeneralInfo: Boot Guard ACM Failure Events(0x" +
+                        to_hex_string(generalInfo) + "), Error Class(0x" +
+                        to_hex_string(eventData[10]) +
+                        "), Major Error Code(0x" +
+                        to_hex_string(eventData[11]) +
+                        "), Minor Error Code(0x" +
+                        to_hex_string(eventData[12]) + ")";
+                    break;
+                }
+                case UnifiedError::UNIFIED_PPR_EVENT:
+                {
+                    uint8_t eventType = eventData[6] & 0x0F;
+                    errorLog = "GeneralInfo: PPR Events(0x" +
+                               to_hex_string(generalInfo) + "), " +
+                               pprEvent[eventType] + ". DIMM Info: (" +
+                               to_hex_string(eventData[7]) +
+                               to_hex_string(eventData[8]) +
+                               to_hex_string(eventData[9]) +
+                               to_hex_string(eventData[10]) +
+                               to_hex_string(eventData[11]) +
+                               to_hex_string(eventData[12]) +
+                               to_hex_string(eventData[13]) + ")";
+                    break;
+                }
+                case UnifiedError::UNIFIED_CXL_MEM_ERR:
+                {
+                    uint8_t eventType = eventData[10] & 0xF;
+                    errorLog =
+                        "GeneralInfo: CXL Memory Error(0x" +
+                        to_hex_string(generalInfo) + "), Bus " +
+                        to_hex_string(eventData[7]) + "/Dev " +
+                        to_hex_string(eventData[8] >> 4) + "/Fun " +
+                        to_hex_string(eventData[8] & 0xF) +
+                        ", Controller ID(0x" + to_hex_string(eventData[11]) +
+                        "), DIMM Failure Event: " + memoryError[eventType];
+                    break;
+                }
+                default:
+                {
+                    errorLog =
+                        "Undefined Error Type(0x" +
+                        to_hex_string(static_cast<uint8_t>(errorType)) +
+                        "), Raw: " + to_hex_string(eventData[1]) +
+                        to_hex_string(eventData[2]) +
+                        to_hex_string(eventData[3]) +
+                        to_hex_string(eventData[4]) +
+                        to_hex_string(eventData[5]) +
+                        to_hex_string(eventData[6]) +
+                        to_hex_string(eventData[7]) +
+                        to_hex_string(eventData[8]) +
+                        to_hex_string(eventData[9]) +
+                        to_hex_string(eventData[10]) +
+                        to_hex_string(eventData[11]) +
+                        to_hex_string(eventData[12]) +
+                        to_hex_string(eventData[13]);
+                    break;
+                }
+            }
+            break;
+        }
+    }
+    auto slotNumber = getSlotNumberString(tid, configurations);
+    std::string message = "Host " + slotNumber + ": " + errorLog;
+    lg2::error("BIOS_IPMI_SEL: {ERROR}", "ERROR",
+               message);                       // Create log in journal
+    pldm::utils::reportError(message.c_str()); // Create log on Dbus
+    return 0;
+}
+
+} // namespace oem_meta
+} // namespace platform_mc
+} // namespace pldm
diff --git a/oem/meta/platform-mc/event_oem_meta.hpp b/oem/meta/platform-mc/event_oem_meta.hpp
new file mode 100644
index 0000000..55822a8
--- /dev/null
+++ b/oem/meta/platform-mc/event_oem_meta.hpp
@@ -0,0 +1,21 @@
+#pragma once
+
+#define PLDM_OEM_EVENT_CLASS_0xFB 0xFB
+
+#include "common/types.hpp"
+#include "requester/configuration_discovery_handler.hpp"
+
+namespace pldm
+{
+namespace platform_mc
+{
+namespace oem_meta
+{
+
+int processOemMetaEvent(
+    pldm_tid_t tid, const uint8_t* eventData, size_t eventDataSize,
+    const std::map<std::string, MctpEndpoint>& configurations);
+
+} // namespace oem_meta
+} // namespace platform_mc
+} // namespace pldm
diff --git a/platform-mc/event_manager.cpp b/platform-mc/event_manager.cpp
index b3c97c5..f0142f1 100644
--- a/platform-mc/event_manager.cpp
+++ b/platform-mc/event_manager.cpp
@@ -3,14 +3,17 @@
 #include "libpldm/platform.h"
 #include "libpldm/utils.h"
 
+#include "requester/configuration_discovery_handler.hpp"
 #include "terminus_manager.hpp"
 
+#include <oem/meta/platform-mc/event_oem_meta.hpp>
 #include <phosphor-logging/lg2.hpp>
 #include <xyz/openbmc_project/Logging/Entry/server.hpp>
 
 #include <cerrno>
 
 PHOSPHOR_LOG2_USING;
+constexpr auto MetaIANA = "0015A000";
 
 namespace pldm
 {
@@ -81,6 +84,23 @@ int decode_pldm_cper_event_data(
     return PLDM_SUCCESS;
 }
 
+bool EventManager::checkMetaIana(
+    pldm_tid_t tid, const std::map<std::string, MctpEndpoint>& configurations)
+{
+    for (const auto& [configDbusPath, mctpEndpoint] : configurations)
+    {
+        if (mctpEndpoint.EndpointId == tid)
+        {
+            if (mctpEndpoint.iana.has_value() &&
+                mctpEndpoint.iana.value() == MetaIANA)
+            {
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
 int EventManager::handlePlatformEvent(
     pldm_tid_t tid, uint16_t eventId, uint8_t eventClass,
     const uint8_t* eventData, size_t eventDataSize)
@@ -145,6 +165,19 @@ int EventManager::handlePlatformEvent(
     {
         return processCperEvent(eventId, eventData, eventDataSize);
     }
+    else if (eventClass == PLDM_OEM_EVENT_CLASS_0xFB)
+    {
+        const std::map<std::string, MctpEndpoint>& configurations =
+            configurationDiscovery->getConfigurations();
+        if (!checkMetaIana(tid, configurations))
+        {
+            lg2::error("Recieve OEM Meta event from not Meta specific device");
+            return PLDM_ERROR;
+        }
+        pldm::platform_mc::oem_meta::processOemMetaEvent(
+            tid, eventData, eventDataSize, configurations);
+        return PLDM_SUCCESS;
+    }
 
     lg2::info("Unsupported class type {CLASSTYPE}", "CLASSTYPE", eventClass);
 
diff --git a/platform-mc/event_manager.hpp b/platform-mc/event_manager.hpp
index c0a7cbe..abe9f19 100644
--- a/platform-mc/event_manager.hpp
+++ b/platform-mc/event_manager.hpp
@@ -6,6 +6,7 @@
 #include "common/types.hpp"
 #include "numeric_sensor.hpp"
 #include "pldmd/dbus_impl_requester.hpp"
+#include "requester/configuration_discovery_handler.hpp"
 #include "requester/handler.hpp"
 #include "terminus.hpp"
 #include "terminus_manager.hpp"
@@ -60,8 +61,10 @@ class EventManager
 
     explicit EventManager(
         TerminusManager& terminusManager,
-        std::map<mctp_eid_t, std::shared_ptr<Terminus>>& termini) :
-        terminusManager(terminusManager), termini(termini)
+        std::map<mctp_eid_t, std::shared_ptr<Terminus>>& termini,
+        pldm::ConfigurationDiscoveryHandler* configurationDiscovery = nullptr) :
+        terminusManager(terminusManager), termini(termini),
+        configurationDiscovery(configurationDiscovery)
     {
         // Default response handler for PollForPlatFormEventMessage
         registerEventHandler(
@@ -170,6 +173,10 @@ class EventManager
     virtual int processCperEvent(uint16_t eventId, const uint8_t* eventData,
                                  size_t eventDataSize);
 
+    bool checkMetaIana(
+        pldm_tid_t tid,
+        const std::map<std::string, MctpEndpoint>& configurations);
+
     int createCperDumpEntry(const std::string& dataType,
                             const std::string& dataPath);
 
@@ -192,6 +199,8 @@ class EventManager
 
     /** @brief map of PLDM event type to EventHandlers */
     EventMap eventHandlers;
+
+    pldm::ConfigurationDiscoveryHandler* configurationDiscovery;
 };
 } // namespace platform_mc
 } // namespace pldm
diff --git a/platform-mc/manager.hpp b/platform-mc/manager.hpp
index 89b8b0a..46d4521 100644
--- a/platform-mc/manager.hpp
+++ b/platform-mc/manager.hpp
@@ -6,11 +6,14 @@
 #include "common/types.hpp"
 #include "event_manager.hpp"
 #include "platform_manager.hpp"
+#include "requester/configuration_discovery_handler.hpp"
 #include "requester/handler.hpp"
 #include "requester/mctp_endpoint_discovery.hpp"
 #include "sensor_manager.hpp"
 #include "terminus_manager.hpp"
 
+#include <oem/meta/platform-mc/event_oem_meta.hpp>
+
 namespace pldm
 {
 namespace platform_mc
@@ -32,13 +35,17 @@ class Manager : public pldm::MctpDiscoveryHandlerIntf
     Manager& operator=(Manager&&) = delete;
     ~Manager() = default;
 
-    explicit Manager(sdeventplus::Event& event, RequesterHandler& handler,
-                     pldm::InstanceIdDb& instanceIdDb) :
+    explicit Manager(
+        sdeventplus::Event& event,
+        requester::Handler<requester::Request>& handler,
+        pldm::InstanceIdDb& instanceIdDb,
+        pldm::ConfigurationDiscoveryHandler* configurationDiscovery) :
         terminusManager(event, handler, instanceIdDb, termini, this,
                         pldm::BmcMctpEid),
         platformManager(terminusManager, termini),
         sensorManager(event, terminusManager, termini, this),
-        eventManager(terminusManager, termini)
+        eventManager(terminusManager, termini, configurationDiscovery),
+        configurationDiscovery(configurationDiscovery)
     {}
 
     /** @brief Helper function to do the actions before discovering terminus
@@ -167,6 +174,18 @@ class Manager : public pldm::MctpDiscoveryHandlerIntf
         return PLDM_SUCCESS;
     }
 
+    int handleOemMetaEvent(const pldm_msg* request, size_t payloadLength,
+                           uint8_t /* formatVersion */, uint8_t tid,
+                           size_t eventDataOffset)
+    {
+        auto eventData = reinterpret_cast<const uint8_t*>(request->payload) +
+                         eventDataOffset;
+        auto eventDataSize = payloadLength - eventDataOffset;
+        eventManager.handlePlatformEvent(tid, 0x00, PLDM_OEM_EVENT_CLASS_0xFB,
+                                         eventData, eventDataSize);
+        return PLDM_SUCCESS;
+    }
+
     /** @brief The function to trigger the event polling
      *
      *  @param[in] tid - Terminus ID
@@ -192,6 +211,7 @@ class Manager : public pldm::MctpDiscoveryHandlerIntf
 
     /** @brief Store event manager handler */
     EventManager eventManager;
+    pldm::ConfigurationDiscoveryHandler* configurationDiscovery;
 };
 } // namespace platform_mc
 } // namespace pldm
diff --git a/platform-mc/test/meson.build b/platform-mc/test/meson.build
index 0e8bc87..d1bf36e 100644
--- a/platform-mc/test/meson.build
+++ b/platform-mc/test/meson.build
@@ -8,6 +8,8 @@ test_src = declare_dependency(
         '../numeric_sensor.cpp',
         '../event_manager.cpp',
         '../../requester/mctp_endpoint_discovery.cpp',
+        '../../requester/configuration_discovery_handler.cpp',
+        '../../oem/meta/platform-mc/event_oem_meta.cpp',
     ],
     include_directories: ['../../requester', '../../pldmd'],
 )
diff --git a/pldmd/pldmd.cpp b/pldmd/pldmd.cpp
index 3ad4a96..f8d1904 100644
--- a/pldmd/pldmd.cpp
+++ b/pldmd/pldmd.cpp
@@ -287,7 +287,8 @@ int main(int argc, char** argv)
     // Platform handler.
 
     std::unique_ptr<platform_mc::Manager> platformManager =
-        std::make_unique<platform_mc::Manager>(event, reqHandler, instanceIdDb);
+        std::make_unique<platform_mc::Manager>(event, reqHandler, instanceIdDb,
+                                               configurationDiscovery.get());
 
     pldm::responder::platform::EventMap addOnEventHandlers{
         {PLDM_CPER_EVENT_CLASS,
@@ -310,6 +311,13 @@ int main(int argc, char** argv)
                              size_t eventDataOffset) {
              return platformManager->handleSensorEvent(
                  request, payloadLength, formatVersion, tid, eventDataOffset);
+         }}},
+        {PLDM_OEM_EVENT_CLASS_0xFB,
+         {[&platformManager](const pldm_msg* request, size_t payloadLength,
+                             uint8_t formatVersion, uint8_t tid,
+                             size_t eventDataOffset) {
+             return platformManager->handleOemMetaEvent(
+                 request, payloadLength, formatVersion, tid, eventDataOffset);
          }}}};
 
     auto platformHandler = std::make_unique<platform::Handler>(
-- 
2.44.2

